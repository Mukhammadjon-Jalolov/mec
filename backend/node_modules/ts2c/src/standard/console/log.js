"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var template_1 = require("../../template");
var ctypes_1 = require("../../types/ctypes");
var variable_1 = require("../../nodes/variable");
var standard_1 = require("../../standard");
var utils_1 = require("../../types/utils");
var assignment_1 = require("../../nodes/assignment");
var literals_1 = require("../../nodes/literals");
var ConsoleLogResolver = /** @class */ (function () {
    function ConsoleLogResolver() {
    }
    ConsoleLogResolver.prototype.matchesNode = function (typeHelper, call) {
        if (!ts.isPropertyAccessExpression(call.expression))
            return false;
        return call.expression.getText() == "console.log";
    };
    ConsoleLogResolver.prototype.returnType = function (typeHelper, call) {
        return ctypes_1.VoidType;
    };
    ConsoleLogResolver.prototype.createTemplate = function (scope, node) {
        return new CConsoleLog(scope, node);
    };
    ConsoleLogResolver.prototype.needsDisposal = function (typeHelper, node) {
        return false;
    };
    ConsoleLogResolver.prototype.getTempVarName = function (typeHelper, node) {
        return null;
    };
    ConsoleLogResolver.prototype.getEscapeNode = function (typeHelper, node) {
        return null;
    };
    ConsoleLogResolver = __decorate([
        standard_1.StandardCallResolver
    ], ConsoleLogResolver);
    return ConsoleLogResolver;
}());
var CConsoleLog = /** @class */ (function (_super) {
    __extends(CConsoleLog, _super);
    function CConsoleLog(scope, node) {
        var _this = _super.call(this) || this;
        _this.printfCalls = [];
        _this.printfCall = null;
        var printfs = [];
        var printNodes = node.arguments;
        var _loop_1 = function (i_1) {
            var printNode = printNodes[i_1];
            var nodeExpressions = processBinaryExpressions(scope, printNode);
            var stringLit = '';
            nodeExpressions = nodeExpressions.reduce(function (a, c) {
                if (ts.isStringLiteral(c.node))
                    stringLit += template_1.CodeTemplateFactory.templateToString(new literals_1.CString(scope, c.node)).slice(1, -1);
                else {
                    a.push(c);
                    c.prefix = stringLit;
                    stringLit = '';
                }
                return a;
            }, []);
            if (stringLit) {
                if (nodeExpressions.length)
                    nodeExpressions[nodeExpressions.length - 1].postfix = stringLit;
                else
                    nodeExpressions.push({ node: printNode, prefix: '', postfix: '' });
            }
            for (var j = 0; j < nodeExpressions.length; j++) {
                var _a = nodeExpressions[j], node_1 = _a.node, prefix = _a.prefix, postfix = _a.postfix;
                var type = scope.root.typeHelper.getCType(node_1);
                var nodesUnder = utils_1.getAllNodesUnder(node_1);
                var hasSideEffects = nodesUnder.some(function (n) { return utils_1.isSideEffectExpression(n); });
                var accessor = "";
                if (hasSideEffects && (type instanceof ctypes_1.ArrayType || type instanceof ctypes_1.StructType || type instanceof ctypes_1.DictType || type === ctypes_1.UniversalVarType)) {
                    var tempVarName = scope.root.symbolsHelper.addTemp(node_1, "tmp_result");
                    // crutch
                    var tempVarType = type;
                    if (tempVarType instanceof ctypes_1.ArrayType && !tempVarType.isDynamicArray)
                        tempVarType = ctypes_1.getTypeText(tempVarType.elementType) + "*";
                    scope.variables.push(new variable_1.CVariable(scope, tempVarName, tempVarType));
                    printfs.push(new assignment_1.CAssignment(scope, tempVarName, null, tempVarType, node_1, false));
                    accessor = tempVarName;
                }
                else if (ts.isStringLiteral(node_1))
                    accessor = template_1.CodeTemplateFactory.templateToString(new literals_1.CString(scope, node_1)).slice(1, -1).replace(/%/g, "%%");
                else
                    accessor = template_1.CodeTemplateFactory.templateToString(template_1.CodeTemplateFactory.createForNode(scope, node_1));
                var options = {
                    prefix: (i_1 > 0 && j == 0 ? " " : "") + prefix.replace(/%/g, "%%"),
                    postfix: postfix.replace(/%/g, "%%") + (i_1 == printNodes.length - 1 && j == nodeExpressions.length - 1 ? "\\n" : "")
                };
                printfs.push(new CPrintf(scope, node_1, accessor, type, options));
            }
        };
        for (var i_1 = 0; i_1 < printNodes.length; i_1++) {
            _loop_1(i_1);
        }
        _this.printfCalls = printfs.slice(0, -1);
        _this.printfCall = printfs[printfs.length - 1];
        scope.root.headerFlags.printf = true;
        return _this;
    }
    CConsoleLog = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {#if printfCalls.length}\n        {printfCalls => {this}\n}\n    {/if}\n{/statements}\n{printfCall}")
    ], CConsoleLog);
    return CConsoleLog;
}(template_1.CTemplateBase));
function processBinaryExpressions(scope, printNode) {
    var type = scope.root.typeHelper.getCType(printNode);
    if (type == ctypes_1.StringVarType && ts.isBinaryExpression(printNode)) {
        var binExpr = printNode;
        if (binExpr.operatorToken.kind == ts.SyntaxKind.PlusToken) {
            var left = processBinaryExpressions(scope, binExpr.left);
            var right = processBinaryExpressions(scope, binExpr.right);
            return [].concat(left, right);
        }
    }
    return [{ node: printNode, prefix: '', postfix: '' }];
}
var CPrintf = /** @class */ (function () {
    function CPrintf(scope, printNode, accessor, varType, options) {
        var _this = this;
        this.accessor = accessor;
        this.isStringLiteral = false;
        this.quoted = false;
        this.isCString = false;
        this.isRegex = false;
        this.isInteger = false;
        this.isBoolean = false;
        this.isDict = false;
        this.isStruct = false;
        this.isArray = false;
        this.isStaticArray = false;
        this.isUniversalVar = false;
        this.elementPrintfs = [];
        this.elementFormatString = '';
        this.propPrefix = '';
        this.INDENT = '';
        this.isStringLiteral = varType == ctypes_1.StringVarType && printNode.kind == ts.SyntaxKind.StringLiteral;
        this.isCString = varType == ctypes_1.StringVarType;
        this.isRegex = varType == ctypes_1.RegexVarType;
        this.isInteger = varType == ctypes_1.NumberVarType;
        this.isBoolean = varType == ctypes_1.BooleanVarType;
        this.isUniversalVar = varType == ctypes_1.UniversalVarType;
        this.quoted = options.quotedString;
        if (this.isUniversalVar) {
            this.tempVarName = scope.root.symbolsHelper.addTemp(printNode, "tmp_str", false);
            this.needDisposeVarName = scope.root.symbolsHelper.addTemp(printNode, "tmp_need_dispose", false);
            if (!scope.variables.some(function (v) { return v.name == _this.tempVarName; }))
                scope.variables.push(new variable_1.CVariable(scope, this.tempVarName, ctypes_1.StringVarType));
            if (!scope.variables.some(function (v) { return v.name == _this.needDisposeVarName; }))
                scope.variables.push(new variable_1.CVariable(scope, this.needDisposeVarName, ctypes_1.BooleanVarType));
            scope.root.headerFlags.js_var_to_str = true;
        }
        this.PREFIX = options.prefix || '';
        this.POSTFIX = options.postfix || '';
        if (options.propName)
            this.PREFIX = this.PREFIX + options.propName + ": ";
        if (options.indent)
            this.INDENT = options.indent;
        if (varType instanceof ctypes_1.ArrayType) {
            this.isArray = true;
            this.isStaticArray = !varType.isDynamicArray;
            this.elementFormatString = varType.elementType == ctypes_1.NumberVarType ? '%d'
                : varType.elementType == ctypes_1.StringVarType ? '\\"%s\\"' : '';
            this.arraySize = varType.isDynamicArray ? accessor + "->size" : varType.capacity + "";
            if (!this.isStaticArray || !this.elementFormatString || varType.capacity > 3) {
                this.iteratorVarName = scope.root.symbolsHelper.addIterator(printNode);
                scope.variables.push(new variable_1.CVariable(scope, this.iteratorVarName, ctypes_1.NumberVarType));
                var elementAccessor = accessor + (varType.isDynamicArray ? "->data" : "") + "[" + this.iteratorVarName + "]";
                var opts = { quotedString: true, indent: this.INDENT + "    " };
                this.elementPrintfs = [
                    new CPrintf_1(scope, printNode, elementAccessor, varType.elementType, opts)
                ];
            }
        }
        else if (varType instanceof ctypes_1.DictType) {
            this.isDict = true;
            this.iteratorVarName = scope.root.symbolsHelper.addIterator(printNode);
            scope.variables.push(new variable_1.CVariable(scope, this.iteratorVarName, ctypes_1.NumberVarType));
            var opts = { quotedString: true, indent: this.INDENT + "    " };
            this.elementPrintfs = [
                new CPrintf_1(scope, printNode, accessor + "->values->data[" + this.iteratorVarName + "]", varType.elementType, opts)
            ];
        }
        else if (varType instanceof ctypes_1.StructType) {
            this.isStruct = true;
            for (var k in varType.properties) {
                var opts = { quotedString: true, propName: k, indent: this.INDENT + "    " };
                if (varType.propertyDefs[k].recursive) {
                    var objString = "[object Object]";
                    var stringLit = ts.createLiteral(objString);
                    this.elementPrintfs.push(new CPrintf_1(scope, stringLit, objString, ctypes_1.StringVarType, opts));
                }
                else {
                    var propAccessor = accessor + "->" + k;
                    this.elementPrintfs.push(new CPrintf_1(scope, printNode, propAccessor, varType.properties[k], opts));
                }
            }
        }
    }
    CPrintf_1 = CPrintf;
    CPrintf = CPrintf_1 = __decorate([
        template_1.CodeTemplate("\n{#if isStringLiteral}\n    printf(\"{PREFIX}{accessor}{POSTFIX}\");\n{#elseif isCString && quoted}\n    printf(\"{PREFIX}\\\"%s\\\"{POSTFIX}\", {accessor});\n{#elseif isCString}\n    printf(\"{PREFIX}%s{POSTFIX}\", {accessor});\n{#elseif isRegex}\n    printf(\"{PREFIX}%s{POSTFIX}\", {accessor}.str);\n{#elseif isInteger}\n    printf(\"{PREFIX}%d{POSTFIX}\", {accessor});\n{#elseif isBoolean && !PREFIX && !POSTFIX}\n    printf({accessor} ? \"true\" : \"false\");\n{#elseif isBoolean && (PREFIX || POSTFIX)}\n    printf(\"{PREFIX}%s{POSTFIX}\", {accessor} ? \"true\" : \"false\");\n{#elseif isDict}\n    printf(\"{PREFIX}{ \");\n    {INDENT}for ({iteratorVarName} = 0; {iteratorVarName} < {accessor}->index->size; {iteratorVarName}++) {\n    {INDENT}    if ({iteratorVarName} != 0)\n    {INDENT}        printf(\", \");\n    {INDENT}    printf(\"\\\"%s\\\": \", {accessor}->index->data[{iteratorVarName}]);\n    {INDENT}    {elementPrintfs}\n    {INDENT}}\n    {INDENT}printf(\" }{POSTFIX}\");\n{#elseif isStruct}\n    printf(\"{PREFIX}{ \");\n    {INDENT}{elementPrintfs {    printf(\", \");\n    }=> {this}}\n    {INDENT}printf(\" }{POSTFIX}\");\n{#elseif isStaticArray && elementFormatString && +arraySize==1}\n    printf(\"{PREFIX}[ {elementFormatString} ]{POSTFIX}\", {accessor}[0]);\n{#elseif isStaticArray && elementFormatString && +arraySize==2}\n    printf(\"{PREFIX}[ {elementFormatString}, {elementFormatString} ]{POSTFIX}\", {accessor}[0], {accessor}[1]);\n{#elseif isStaticArray && elementFormatString && +arraySize==3}\n    printf(\"{PREFIX}[ {elementFormatString}, {elementFormatString}, {elementFormatString} ]{POSTFIX}\", {accessor}[0], {accessor}[1], {accessor}[2]);\n{#elseif isArray}\n    printf(\"{PREFIX}[ \");\n    {INDENT}for ({iteratorVarName} = 0; {iteratorVarName} < {arraySize}; {iteratorVarName}++) {\n    {INDENT}    if ({iteratorVarName} != 0)\n    {INDENT}        printf(\", \");\n    {INDENT}    {elementPrintfs}\n    {INDENT}}\n    {INDENT}printf(\" ]{POSTFIX}\");\n{#elseif isUniversalVar && quoted}\n    printf({accessor}.type == JS_VAR_STRING ? \"{PREFIX}\\\"%s\\\"{POSTFIX}\" : \"{PREFIX}%s{POSTFIX}\", {tempVarName} = js_var_to_str({accessor}, &{needDisposeVarName}));\n    {INDENT}if ({needDisposeVarName})\n    {INDENT}    free((void *){tempVarName});\n{#elseif isUniversalVar}\n    printf(\"{PREFIX}%s{POSTFIX}\", {tempVarName} = js_var_to_str({accessor}, &{needDisposeVarName}));\n    {INDENT}if ({needDisposeVarName})\n    {INDENT}    free((void *){tempVarName});\n{#else}\n    printf(/* Unsupported printf expression */);\n{/if}")
    ], CPrintf);
    return CPrintf;
    var CPrintf_1;
}());
//# sourceMappingURL=log.js.map