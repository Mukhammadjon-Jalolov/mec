"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var ctypes_1 = require("./types/ctypes");
var standard_1 = require("./standard");
var match_1 = require("./standard/string/match");
var utils_1 = require("./types/utils");
var MemoryManager = /** @class */ (function () {
    function MemoryManager(typeHelper, symbolsHelper) {
        this.typeHelper = typeHelper;
        this.symbolsHelper = symbolsHelper;
        this.scopes = {};
        this.scopesOfVariables = {};
        this.reusedVariables = {};
        this.originalNodes = {};
        this.references = {};
        this.needsGCMain = false;
    }
    MemoryManager.prototype.scheduleNodeDisposals = function (nodes) {
        var _this = this;
        nodes.filter(function (n) { return ts.isIdentifier(n); }).forEach(function (n) {
            var decl = _this.typeHelper.getDeclaration(n);
            if (decl) {
                _this.references[decl.pos] = _this.references[decl.pos] || [];
                _this.references[decl.pos].push(n);
            }
        });
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
            var node = nodes_1[_i];
            switch (node.kind) {
                case ts.SyntaxKind.ArrayLiteralExpression:
                    {
                        var type = this.typeHelper.getCType(node);
                        if (type && type instanceof ctypes_1.ArrayType && type.isDynamicArray || type === ctypes_1.UniversalVarType)
                            this.scheduleNodeDisposal(node, { canReuse: type !== ctypes_1.UniversalVarType });
                    }
                    break;
                case ts.SyntaxKind.ObjectLiteralExpression:
                    {
                        var type = this.typeHelper.getCType(node);
                        this.scheduleNodeDisposal(node, { canReuse: type !== ctypes_1.UniversalVarType });
                    }
                    break;
                case ts.SyntaxKind.BinaryExpression:
                    {
                        var binExpr = node;
                        var leftType = this.typeHelper.getCType(binExpr.left);
                        var rightType = this.typeHelper.getCType(binExpr.right);
                        if (utils_1.isPlusOp(binExpr.operatorToken.kind)) {
                            if (leftType == ctypes_1.UniversalVarType || rightType == ctypes_1.UniversalVarType)
                                this.needsGCMain = true;
                            else {
                                var n = binExpr;
                                while (ts.isBinaryExpression(n.parent) && utils_1.isPlusOp(n.parent.operatorToken.kind))
                                    n = n.parent;
                                var isInConsoleLog = ts.isCallExpression(n.parent) && n.parent.expression.getText() == "console.log";
                                if (!isInConsoleLog && (utils_1.toPrimitive(leftType) == ctypes_1.StringVarType || utils_1.toPrimitive(rightType) == ctypes_1.StringVarType))
                                    this.scheduleNodeDisposal(binExpr, { canReuse: false });
                            }
                        }
                        if (binExpr.operatorToken.kind === ts.SyntaxKind.InKeyword
                            && !(rightType instanceof ctypes_1.ArrayType)
                            && (leftType === ctypes_1.UniversalVarType || leftType instanceof ctypes_1.ArrayType || leftType === ctypes_1.NumberVarType && !ts.isNumericLiteral(binExpr.left)))
                            this.needsGCMain = true;
                    }
                    break;
                case ts.SyntaxKind.CallExpression:
                    {
                        if (standard_1.StandardCallHelper.needsDisposal(this.typeHelper, node))
                            this.scheduleNodeDisposal(node);
                    }
                    break;
                case ts.SyntaxKind.NewExpression:
                    {
                        this.scheduleNodeDisposal(node);
                    }
                    break;
                case ts.SyntaxKind.FunctionExpression:
                case ts.SyntaxKind.FunctionDeclaration:
                    {
                        var type = this.typeHelper.getCType(node);
                        var parentFunc = utils_1.findParentFunction(node.parent);
                        if (parentFunc && type instanceof ctypes_1.FuncType && type.needsClosureStruct)
                            this.scheduleNodeDisposal(node, { subtype: "closure" });
                        else if (type instanceof ctypes_1.FuncType && type.scopeType)
                            this.scheduleNodeDisposal(node, { subtype: "scope", canReuse: false });
                    }
                    break;
            }
        }
    };
    MemoryManager.prototype.getGCVariablesForScope = function (node) {
        var parentDecl = utils_1.findParentFunction(node);
        var scopeId = parentDecl && parentDecl.pos + 1 + "" || "main";
        var realScopeId = this.scopes[scopeId] && this.scopes[scopeId].length && this.scopes[scopeId][0].scopeId;
        var gcVars = [];
        if (this.scopes[scopeId] && this.scopes[scopeId].filter(function (v) { return !v.simple && !v.array && !v.dict && !v.arrayWithContents; }).length) {
            gcVars.push("gc_" + realScopeId);
        }
        if (scopeId == "main" && this.needsGCMain && gcVars[0] != "gc_main") {
            gcVars.push("gc_main");
        }
        if (this.scopes[scopeId] && this.scopes[scopeId].filter(function (v) { return !v.simple && v.array; }).length) {
            gcVars.push("gc_" + realScopeId + "_arrays");
        }
        if (this.scopes[scopeId] && this.scopes[scopeId].filter(function (v) { return !v.simple && v.arrayWithContents; }).length) {
            gcVars.push("gc_" + realScopeId + "_arrays_c");
        }
        if (this.scopes[scopeId] && this.scopes[scopeId].filter(function (v) { return !v.simple && v.dict; }).length) {
            gcVars.push("gc_" + realScopeId + "_dicts");
        }
        return gcVars;
    };
    MemoryManager.prototype.getGCVariableForNode = function (node) {
        var key = node.pos + "_" + node.end;
        if (this.reusedVariables[key])
            key = this.reusedVariables[key];
        if (this.scopesOfVariables[key] && !this.scopesOfVariables[key].simple) {
            if (this.scopesOfVariables[key].array)
                return "gc_" + this.scopesOfVariables[key].scopeId + "_arrays";
            else if (this.scopesOfVariables[key].arrayWithContents)
                return "gc_" + this.scopesOfVariables[key].scopeId + "_arrays_c";
            else if (this.scopesOfVariables[key].dict)
                return "gc_" + this.scopesOfVariables[key].scopeId + "_dicts";
            else
                return "gc_" + this.scopesOfVariables[key].scopeId;
        }
        else
            return null;
    };
    MemoryManager.prototype.getDestructorsForScope = function (node) {
        var parentDecl = utils_1.findParentFunction(node);
        var scopeId = parentDecl && parentDecl.pos + 1 || "main";
        var destructors = [];
        if (this.scopes[scopeId]) {
            // string match allocates array of strings, and each of those strings should be also disposed
            for (var _i = 0, _a = this.scopes[scopeId].filter(function (v) { return v.simple && v.used; }); _i < _a.length; _i++) {
                var simpleVarScopeInfo = _a[_i];
                var type = this.typeHelper.getCType(simpleVarScopeInfo.node);
                destructors.push({
                    varName: simpleVarScopeInfo.varName,
                    array: simpleVarScopeInfo.array,
                    dict: simpleVarScopeInfo.dict,
                    string: type == ctypes_1.StringVarType,
                    arrayWithContents: simpleVarScopeInfo.arrayWithContents
                });
            }
        }
        return destructors;
    };
    MemoryManager.prototype.variableWasReused = function (node) {
        var key = node.pos + "_" + node.end;
        return !!this.reusedVariables[key];
    };
    /** Variables that need to be disposed are tracked by memory manager */
    MemoryManager.prototype.getReservedTemporaryVarName = function (node) {
        var key = node.pos + "_" + node.end;
        if (this.reusedVariables[key])
            key = this.reusedVariables[key];
        var scopeOfVar = this.scopesOfVariables[key];
        if (scopeOfVar) {
            scopeOfVar.used = true;
            return scopeOfVar.varName;
        }
        else
            return null;
    };
    /** Sometimes we can reuse existing variable instead of creating a temporary one. */
    MemoryManager.prototype.tryReuseExistingVariable = function (node) {
        if (ts.isBinaryExpression(node.parent) && ts.isIdentifier(node.parent.left) && node.parent.operatorToken.kind == ts.SyntaxKind.EqualsToken)
            return node.parent.left;
        if (ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name))
            return node.parent.name;
        return null;
    };
    MemoryManager.prototype.scheduleNodeDisposal = function (heapNode, options) {
        options = __assign({ canReuse: true, subtype: null }, options);
        var isTemp = true;
        if (options.canReuse) {
            var existingVariable = this.tryReuseExistingVariable(heapNode);
            isTemp = existingVariable == null;
            if (!isTemp) {
                this.reusedVariables[heapNode.pos + "_" + heapNode.end] = existingVariable.pos + "_" + existingVariable.end;
                this.originalNodes[existingVariable.pos + "_" + existingVariable.end] = heapNode;
                heapNode = existingVariable;
            }
        }
        var topScopeNode = utils_1.findParentFunction(heapNode);
        var topScope = topScopeNode && topScopeNode.pos + 1 || "main";
        var isSimple = true;
        if (this.isInsideLoop(heapNode))
            isSimple = false;
        var scopeTree = {};
        scopeTree[topScope] = true;
        var queue = [{ node: heapNode, nodeFunc: null }];
        if (options.subtype === "scope")
            queue = this.getStartNodesForTrekingFunctionScope(heapNode).map(function (n) { return ({ node: n, nodeFunc: null }); });
        var visited = {};
        while (queue.length > 0) {
            var _a = queue.shift(), node = _a.node, nodeFunc = _a.nodeFunc;
            if (visited[node.pos + "_" + node.end])
                continue;
            var refs = [node];
            if (node.kind == ts.SyntaxKind.Identifier) {
                var decl = this.typeHelper.getDeclaration(node);
                if (decl)
                    refs = this.references[decl.pos] || refs;
            }
            else if (ts.isFunctionDeclaration(node)) {
                refs = this.references[node.pos] || refs;
            }
            var returned = false;
            for (var _i = 0, refs_1 = refs; _i < refs_1.length; _i++) {
                var ref = refs_1[_i];
                visited[ref.pos + "_" + ref.end] = true;
                var parentNode = utils_1.findParentFunction(utils_1.isFunction(ref) ? ref.parent : ref);
                if (!parentNode)
                    topScope = "main";
                if (ts.isElementAccessExpression(ref) || ts.isPropertyAccessExpression(ref)) {
                    var elemAccess = ref;
                    while (ts.isElementAccessExpression(elemAccess.expression) || ts.isPropertyAccessExpression(elemAccess.expression))
                        elemAccess = elemAccess.expression;
                    if (ts.isIdentifier(elemAccess.expression)) {
                        console.log(heapNode.getText() + " -> Tracking parent variable: " + elemAccess.expression.getText() + ".");
                        queue.push({ node: elemAccess.expression, nodeFunc: nodeFunc });
                    }
                }
                if (ref.parent && ts.isElementAccessExpression(ref.parent) && ref.parent.argumentExpression === ref) {
                    var type_1 = this.typeHelper.getCType(ref.parent.expression);
                    if (type_1 instanceof ctypes_1.DictType) {
                        console.log(heapNode.getText() + " -> Property of dictionary " + ref.parent.expression.getText() + ".");
                        queue.push({ node: ref.parent.expression, nodeFunc: nodeFunc });
                    }
                }
                if (ref.parent && ref.parent.kind == ts.SyntaxKind.BinaryExpression) {
                    var binaryExpr = ref.parent;
                    if (binaryExpr.operatorToken.kind == ts.SyntaxKind.EqualsToken && binaryExpr.left.getText() == heapNode.getText()) {
                        console.log(heapNode.getText() + " -> Detected assignment: " + binaryExpr.getText() + ".");
                        isSimple = false;
                    }
                }
                if (ref.parent && ref.parent.kind == ts.SyntaxKind.PropertyAssignment) {
                    console.log(heapNode.getText() + " -> Detected passing to object literal: " + ref.parent.getText() + ".");
                    queue.push({ node: ref.parent.parent, nodeFunc: nodeFunc });
                }
                if (ref.parent && ref.parent.kind == ts.SyntaxKind.ArrayLiteralExpression) {
                    console.log(heapNode.getText() + " -> Detected passing to array literal: " + ref.parent.getText() + ".");
                    queue.push({ node: ref.parent, nodeFunc: nodeFunc });
                }
                if (ref.parent && ref.parent.kind == ts.SyntaxKind.ParenthesizedExpression) {
                    console.log(heapNode.getText() + " -> Found parenthesized expression.");
                    queue.push({ node: ref.parent, nodeFunc: nodeFunc });
                }
                if (ref.parent && ref.parent.kind == ts.SyntaxKind.CallExpression) {
                    var call = ref.parent;
                    if (ts.isIdentifier(call.expression) && call.expression === ref) {
                        console.log(heapNode.getText() + " -> Found function call!");
                        if (topScope !== "main") {
                            var funcNode = utils_1.findParentFunction(call);
                            topScope = funcNode && funcNode.pos + 1 || "main";
                            var targetScope = nodeFunc && nodeFunc.pos + 1 + "" || "none";
                            isSimple = false;
                            if (scopeTree[targetScope])
                                delete scopeTree[targetScope];
                            scopeTree[topScope] = targetScope;
                        }
                        if (ts.isReturnStatement(call.parent) && !returned) {
                            queue.push({ node: ts.isFunctionExpression(parentNode) ? parentNode : parentNode.name, nodeFunc: parentNode });
                            console.log(heapNode.getText() + " -> Found variable returned from the function!");
                            returned = true;
                            isSimple = false;
                        }
                        else
                            this.addIfFoundInAssignment(heapNode, call, queue, nodeFunc);
                    }
                    else if (call.expression === ref) {
                        console.log(heapNode.getText() + " -> Found function expression call!");
                        isSimple = false;
                        queue.push({ node: call, nodeFunc: nodeFunc });
                    }
                    else {
                        var decl = this.typeHelper.getDeclaration(call.expression);
                        if (!decl) {
                            var isStandardCall = standard_1.StandardCallHelper.isStandardCall(this.typeHelper, call);
                            if (isStandardCall) {
                                var standardCallEscapeNode = standard_1.StandardCallHelper.getEscapeNode(this.typeHelper, call);
                                if (standardCallEscapeNode) {
                                    console.log(heapNode.getText() + " escapes to '" + standardCallEscapeNode.getText() + "' via standard call '" + call.getText() + "'.");
                                    queue.push({ node: standardCallEscapeNode, nodeFunc: nodeFunc });
                                }
                            }
                            else {
                                console.log(heapNode.getText() + " -> Detected passing to external function " + call.expression.getText() + "." + (topScope != "main" ? "Scope changed to main." : ""));
                                topScope = "main";
                            }
                        }
                        else {
                            var funcDecl = decl;
                            for (var i_1 = 0; i_1 < call.arguments.length; i_1++) {
                                if (call.arguments[i_1].pos <= ref.pos && call.arguments[i_1].end >= ref.end) {
                                    if (funcDecl.pos + 1 == topScope) {
                                        console.log(heapNode.getText() + " -> Found recursive call with parameter " + funcDecl.parameters[i_1].name.getText());
                                        queue.push({ node: funcDecl.name, nodeFunc: nodeFunc });
                                    }
                                    else {
                                        console.log(heapNode.getText() + " -> Found passing to function " + call.expression.getText() + " as parameter " + funcDecl.parameters[i_1].name.getText());
                                        queue.push({ node: funcDecl.parameters[i_1].name, nodeFunc: nodeFunc });
                                    }
                                    isSimple = false;
                                }
                            }
                        }
                    }
                }
                else if (ts.isReturnStatement(ref.parent) && !returned) {
                    queue.push({ node: ts.isFunctionExpression(parentNode) ? parentNode : parentNode.name, nodeFunc: parentNode });
                    console.log(heapNode.getText() + " -> Found variable returned from the function!");
                    returned = true;
                    isSimple = false;
                }
                else
                    this.addIfFoundInAssignment(heapNode, ref, queue, nodeFunc);
            }
        }
        var type = this.typeHelper.getCType(heapNode);
        var varName;
        if (!isTemp)
            varName = heapNode.getText().replace(/\./g, '->');
        else if (ts.isStringLiteral(heapNode))
            varName = this.symbolsHelper.addTemp(heapNode, "tmp_string");
        else if (ts.isNumericLiteral(heapNode))
            varName = this.symbolsHelper.addTemp(heapNode, "tmp_number");
        else if (ts.isArrayLiteralExpression(heapNode))
            varName = this.symbolsHelper.addTemp(heapNode, "tmp_array");
        else if (ts.isObjectLiteralExpression(heapNode))
            varName = this.symbolsHelper.addTemp(heapNode, "tmp_obj");
        else if (ts.isBinaryExpression(heapNode))
            varName = this.symbolsHelper.addTemp(heapNode, "tmp_result");
        else if (ts.isPrefixUnaryExpression(heapNode))
            varName = this.symbolsHelper.addTemp(heapNode, "tmp_number");
        else if (ts.isCallExpression(heapNode))
            varName = this.symbolsHelper.addTemp(heapNode, standard_1.StandardCallHelper.getTempVarName(this.typeHelper, heapNode));
        else if (ts.isIdentifier(heapNode))
            varName = this.symbolsHelper.addTemp(heapNode, heapNode.text);
        else if (utils_1.isFunction(heapNode)) {
            var suffix = options.subtype || "tmp";
            var maybePropertyName = ts.isPropertyAssignment(heapNode.parent) && ts.isIdentifier(heapNode.parent.name) ? heapNode.parent.name.text + "_" + suffix : suffix;
            var name_1 = heapNode.name ? heapNode.name.text + "_" + suffix : maybePropertyName;
            varName = this.symbolsHelper.addTemp(utils_1.findParentSourceFile(heapNode), name_1);
        }
        else
            varName = this.symbolsHelper.addTemp(heapNode, "tmp");
        var vnode = heapNode;
        var key = vnode.pos + "_" + vnode.end;
        var arrayWithContents = false;
        if (this.originalNodes[key])
            vnode = this.originalNodes[key];
        if (vnode.kind == ts.SyntaxKind.CallExpression && new match_1.StringMatchResolver().matchesNode(this.typeHelper, vnode))
            arrayWithContents = true;
        var foundScopes = topScope == "main" ? [topScope] : Object.keys(scopeTree);
        var scopeInfo = {
            node: heapNode,
            simple: isSimple,
            arrayWithContents: arrayWithContents,
            array: !arrayWithContents && type && type instanceof ctypes_1.ArrayType && type.isDynamicArray || type === ctypes_1.UniversalVarType && ts.isArrayLiteralExpression(heapNode),
            dict: type && type instanceof ctypes_1.DictType || type === ctypes_1.UniversalVarType && ts.isObjectLiteralExpression(heapNode),
            varName: varName,
            scopeId: foundScopes.join("_"),
            used: !isTemp
        };
        this.scopesOfVariables[heapNode.pos + "_" + heapNode.end] = scopeInfo;
        for (var _b = 0, foundScopes_1 = foundScopes; _b < foundScopes_1.length; _b++) {
            var sc = foundScopes_1[_b];
            this.scopes[sc] = this.scopes[sc] || [];
            this.scopes[sc].push(scopeInfo);
        }
    };
    MemoryManager.prototype.getStartNodesForTrekingFunctionScope = function (func) {
        var allNodesInFunc = utils_1.getAllNodesInFunction(func);
        var startNodes = [];
        for (var _i = 0, allNodesInFunc_1 = allNodesInFunc; _i < allNodesInFunc_1.length; _i++) {
            var node = allNodesInFunc_1[_i];
            var type = this.typeHelper.getCType(node);
            if (type instanceof ctypes_1.FuncType && type.needsClosureStruct)
                startNodes.push(node);
        }
        return startNodes;
    };
    MemoryManager.prototype.addIfFoundInAssignment = function (varIdent, ref, queue, nodeFunc) {
        if (ref.parent && ref.parent.kind == ts.SyntaxKind.VariableDeclaration) {
            var varDecl = ref.parent;
            if (varDecl.initializer && varDecl.initializer.pos == ref.pos) {
                queue.push({ node: varDecl.name, nodeFunc: nodeFunc });
                console.log(varIdent.getText() + " -> Found initializer-assignment to variable " + varDecl.name.getText());
                return true;
            }
        }
        else if (ref.parent && ref.parent.kind == ts.SyntaxKind.BinaryExpression) {
            var binaryExpr = ref.parent;
            if (binaryExpr.operatorToken.kind == ts.SyntaxKind.FirstAssignment && binaryExpr.right.pos == ref.pos) {
                queue.push({ node: binaryExpr.left, nodeFunc: nodeFunc });
                console.log(varIdent.getText() + " -> Found assignment to variable " + binaryExpr.left.getText());
                return true;
            }
        }
        return false;
    };
    MemoryManager.prototype.isInsideLoop = function (node) {
        var parent = node;
        while (parent
            && parent.kind != ts.SyntaxKind.ForInStatement
            && parent.kind != ts.SyntaxKind.ForOfStatement
            && parent.kind != ts.SyntaxKind.ForStatement
            && parent.kind != ts.SyntaxKind.WhileStatement
            && parent.kind != ts.SyntaxKind.DoStatement) {
            parent = parent.parent;
        }
        return !!parent;
    };
    return MemoryManager;
}());
exports.MemoryManager = MemoryManager;
//# sourceMappingURL=memory.js.map