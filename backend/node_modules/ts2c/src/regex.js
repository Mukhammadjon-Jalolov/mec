"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var NOTHING = { nothing: true };
var FIXED_START = { fixedStart: true };
var FIXED_END = { fixedEnd: true };
Array.prototype["removeDuplicates"] = function () {
    return this.filter(function (item, pos, self) { return self.indexOf(item) == pos; });
};
function isStartGroup(t) { return t && !!t.startGroup || false; }
function isEndGroup(t) { return t && !!t.endGroup || false; }
function isRangeCondition(t) { return t && !!t.fromChar && !!t.toChar || false; }
exports.isRangeCondition = isRangeCondition;
;
var RegexParser = /** @class */ (function () {
    function RegexParser() {
    }
    RegexParser.parseEscaped = function (c) {
        if (c == 'd')
            return ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        else if (c == 'w')
            return [
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'W', 'Z',
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'w', 'z',
                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '_'
            ];
        else if (c == 'n')
            return ['\n'];
        else if (c == 's')
            return ['\t', ' '];
        else
            return [c];
    };
    RegexParser.parseChars = function (template, i, mode) {
        var token = { tokens: [] };
        token[mode] = true;
        while (template[i] != ']') {
            if (template[i] == '\\')
                i++ && (token.tokens = token.tokens.concat(this.parseEscaped(template[i])));
            else if (template[i + 1] == '-' && template[i + 2] != ']') {
                var ch = template[i];
                i++;
                i++;
                while (ch.charCodeAt(0) <= template[i].charCodeAt(0)) {
                    token.tokens.push(ch);
                    ch = String.fromCharCode(ch.charCodeAt(0) + 1);
                }
            }
            else
                token.tokens.push(template[i]);
            i++;
        }
        return [token.tokens.length ? token : null, i];
    };
    RegexParser.parse = function (template, isGroup, group) {
        if (isGroup === void 0) { isGroup = false; }
        if (group === void 0) { group = 0; }
        var rootToken = { tokens: [] };
        var tokens = [];
        var lastToken = function () { return tokens.slice(-1)[0]; };
        var tok = null;
        var i = 0;
        while (i < template.length) {
            var last = lastToken();
            if (template[i] == '^' && tokens.length == 0)
                tokens.push(FIXED_START);
            else if (template[i] == '$' && i == template.length - 1 || template.slice(i, i + 2) == '$)' || template.slice(i, i + 2) == '$|')
                tokens.push(FIXED_END);
            else if (template[i] == '\\')
                i++, tokens.push({ anyOf: true, tokens: this.parseEscaped(template[i]) });
            else if (template[i] == '.')
                tokens.push({ anyCharExcept: true, tokens: [] });
            else if (template[i] == '*') {
                tokens.pop();
                if (typeof last === "string")
                    tokens.push({ anyOf: true, tokens: [NOTHING, { tokens: [last], oneOrMore: true }] });
                else
                    tokens.push({ anyOf: true, tokens: [NOTHING, __assign({}, last, { oneOrMore: true })] });
            }
            else if (template[i] == '?')
                tokens.push({ anyOf: true, tokens: [NOTHING, tokens.pop()] });
            else if (template[i] == '+')
                if (typeof last === "string")
                    tokens.push({ oneOrMore: true, tokens: [tokens.pop()] });
                else
                    last.oneOrMore = true;
            else if (template[i] == '|') {
                rootToken.tokens.push(tokens.length ? { tokens: tokens } : NOTHING);
                rootToken.anyOf = true;
                tokens = [];
            }
            else if (template.slice(i, i + 3) == '(?:')
                i += 3, (_a = this.parse(template.slice(i), true, group), group = _a.group, tok = _a.tokenTree, _a) && tok && tokens.push(tok) && (i += tok.template.length);
            else if (template[i] == '(') {
                var nextGroup = void 0;
                i++, group++;
                (_b = this.parse(template.slice(i), true, group), nextGroup = _b.group, tok = _b.tokenTree);
                tok && tokens.push({ tokens: [{ startGroup: group }, tok, { endGroup: group }] }) && (i += tok.template.length);
                group = nextGroup;
            }
            else if (template[i] == ')' && isGroup)
                break;
            else if (template.slice(i, i + 2) == '[^')
                i += 2, (_c = this.parseChars(template, i, 'anyCharExcept'), tok = _c[0], i = _c[1], _c) && tok && tokens.push(tok);
            else if (template[i] == '[')
                i++, (_d = this.parseChars(template, i, 'anyOf'), tok = _d[0], i = _d[1], _d) && tok && tokens.push(tok);
            else
                tokens.push(template[i]);
            i++;
        }
        if (rootToken.anyOf)
            rootToken.tokens.push(tokens.length ? { tokens: tokens } : NOTHING);
        else
            rootToken.tokens = tokens;
        rootToken.template = template.slice(0, i);
        return { group: group, tokenTree: isGroup && rootToken.tokens.length == 0 ? null : rootToken };
        var _a, _b, _c, _d;
    };
    return RegexParser;
}());
var RegexBuilder = /** @class */ (function () {
    function RegexBuilder() {
    }
    RegexBuilder.convert = function (token, transitions, firstFromState, finalState) {
        if (transitions === void 0) { transitions = []; }
        if (firstFromState === void 0) { firstFromState = 0; }
        if (finalState === void 0) { finalState = 0; }
        var nextFromState = [firstFromState];
        if (typeof token == "string" || token.anyCharExcept) {
            transitions.push({ token: token, fromState: firstFromState, toState: ++finalState });
            nextFromState = [finalState];
        }
        else if (token.anyOf) {
            var lastTransitions = [];
            if (token.tokens.indexOf(NOTHING) > -1)
                nextFromState = [firstFromState];
            else
                nextFromState = [];
            for (var _i = 0, _a = token.tokens.filter(function (t) { return t != NOTHING && t != FIXED_START && t != FIXED_END && !isStartGroup(t) && !isEndGroup(t); }); _i < _a.length; _i++) {
                var tok = _a[_i];
                var l = transitions.length;
                var result = this.convert(tok, transitions, firstFromState, finalState);
                finalState = result.finalState;
                if (result.nextFromState.length > 1)
                    nextFromState = nextFromState.concat(result.nextFromState.filter(function (n) { return n != finalState; }));
                lastTransitions = lastTransitions.concat(transitions.slice(l).filter(function (t) { return t.toState == finalState; }));
            }
            nextFromState = nextFromState.concat(finalState).removeDuplicates();
            lastTransitions.forEach(function (ls) { return ls.toState = finalState; });
        }
        else {
            for (var _b = 0, _c = token.tokens.filter(function (t) { return t != FIXED_START && t != FIXED_END && !isStartGroup(t) && !isEndGroup(t); }); _b < _c.length; _b++) {
                var tok = _c[_b];
                var results = [];
                var lastTransitions = [];
                var _loop_1 = function (fromState) {
                    var l = transitions.length;
                    var result = this_1.convert(tok, transitions, fromState, finalState);
                    lastTransitions = lastTransitions.concat(transitions.slice(l).filter(function (t) { return t.toState == result.finalState; }));
                    results.push(result);
                };
                var this_1 = this;
                for (var _d = 0, nextFromState_1 = nextFromState; _d < nextFromState_1.length; _d++) {
                    var fromState = nextFromState_1[_d];
                    _loop_1(fromState);
                }
                nextFromState = [].concat.apply([], results.map(function (r) { return r.nextFromState; })).removeDuplicates();
                finalState = results.map(function (r) { return r.finalState; }).reduce(function (a, b) { return Math.max(a, b); }, 0);
            }
        }
        if (typeof token != "string" && token.oneOrMore) {
            for (var _e = 0, _f = transitions.filter(function (t) { return t.toState == finalState; }); _e < _f.length; _e++) {
                var tr = _f[_e];
                transitions.push(__assign({}, tr, { toState: firstFromState }));
            }
        }
        if (typeof token != "string" && token.tokens[0] == FIXED_START) {
            transitions.filter(function (t) { return t.fromState == firstFromState; }).forEach(function (t) { return t.fixedStart = true; });
        }
        if (typeof token != "string" && token.tokens[token.tokens.length - 1] == FIXED_END) {
            transitions.filter(function (t) { return t.toState == finalState; }).forEach(function (t) { return t.fixedEnd = true; });
        }
        var groupTok;
        if (typeof token != "string" && isStartGroup(groupTok = token.tokens[0])) {
            transitions.filter(function (t) { return t.fromState == firstFromState; }).forEach(function (t) {
                t.startGroup = t.startGroup || [];
                if (t.startGroup.indexOf(groupTok.startGroup) == -1)
                    t.startGroup.push(groupTok.startGroup);
            });
        }
        if (typeof token != "string" && isEndGroup(groupTok = token.tokens[token.tokens.length - 1])) {
            transitions.filter(function (t) { return t.toState == finalState; }).forEach(function (t) {
                t.endGroup = t.endGroup || [];
                if (t.endGroup.indexOf(groupTok.endGroup) == -1)
                    t.endGroup.push(groupTok.endGroup);
            });
        }
        return { transitions: transitions, nextFromState: nextFromState, finalState: finalState };
    };
    RegexBuilder.normalize = function (transitions, finalStates) {
        if (!transitions.length)
            return [];
        var states = [];
        var _loop_2 = function (finalState) {
            if (transitions.map(function (t) { return t.fromState; }).indexOf(finalState) == -1) {
                transitions.push({ fromState: finalState, final: true });
            }
            else
                transitions.filter(function (t) { return t.fromState == finalState; }).forEach(function (t) { return t.final = true; });
        };
        for (var _i = 0, finalStates_1 = finalStates; _i < finalStates_1.length; _i++) {
            var finalState = finalStates_1[_i];
            _loop_2(finalState);
        }
        // split anyChar transitions
        var addedTransitions = [];
        var charTransitions = transitions.filter(function (t) { return typeof t.token == "string"; });
        var anyCharTransitions = transitions.filter(function (t) { return typeof t.token != "string" && t.token != null; });
        var _loop_3 = function (anyCharT) {
            var _loop_4 = function (charT) {
                var anyCharT_token = anyCharT.token;
                if (charT.fromState == anyCharT.fromState && anyCharT.toState != charT.toState && anyCharT_token.tokens.indexOf(charT.token) == -1) {
                    if (transitions.filter(function (t) { return t.fromState == anyCharT.fromState && t.toState == anyCharT.toState && t.token == charT.token; }).length == 0)
                        addedTransitions.push({ fromState: anyCharT.fromState, toState: anyCharT.toState, token: charT.token, startGroup: anyCharT.startGroup, endGroup: anyCharT.endGroup });
                }
            };
            for (var _i = 0, charTransitions_1 = charTransitions; _i < charTransitions_1.length; _i++) {
                var charT = charTransitions_1[_i];
                _loop_4(charT);
            }
        };
        for (var _a = 0, anyCharTransitions_1 = anyCharTransitions; _a < anyCharTransitions_1.length; _a++) {
            var anyCharT = anyCharTransitions_1[_a];
            _loop_3(anyCharT);
        }
        transitions = transitions.concat(addedTransitions);
        var stateIndices = {};
        var processed = {};
        var ensureId = function (tt) {
            var id = tt.map(function (t) { return t.fromState; }).removeDuplicates().sort().join(",");
            if (stateIndices[id] == null) {
                stateIndices[id] = Object.keys(stateIndices).length;
            }
            return stateIndices[id];
        };
        var queue = [transitions.filter(function (t) { return t.fromState == 0; })];
        var _loop_5 = function () {
            var trgroup = queue.pop();
            var id = ensureId(trgroup);
            if (processed[id])
                return "continue";
            states.push({ transitions: [] });
            if (trgroup.filter(function (t) { return t.final; }).length > 0)
                states[states.length - 1].final = true;
            processed[id] = true;
            var processedTr = [];
            var _loop_6 = function (tr) {
                var group = trgroup.filter(function (t) { return JSON.stringify(tr.token) === JSON.stringify(t.token) && processedTr.indexOf(t) == -1; });
                if (!group.length)
                    return "continue";
                group.forEach(function (g) { return processedTr.push(g); });
                var reachableStates = group.map(function (g) { return g.toState; });
                var closure = transitions.filter(function (t) { return reachableStates.indexOf(t.fromState) > -1; });
                var closureId = ensureId(closure);
                var sameTokenTransactions = trgroup.filter(function (t) { return JSON.stringify(tr.token) === JSON.stringify(t.token); });
                var startGr = sameTokenTransactions.map(function (t) { return t.startGroup; }).reduce(function (a, c) { return c == null ? a : a.concat(c); }, []).reduce(function (a, c) { a.indexOf(c) == -1 && a.push(c); return a; }, []);
                var endGr = sameTokenTransactions.map(function (t) { return t.endGroup; }).reduce(function (a, c) { return c == null ? a : a.concat(c); }, []).reduce(function (a, c) { a.indexOf(c) == -1 && a.push(c); return a; }, []);
                states[id].transitions.push({ condition: tr.token, next: closureId, fixedStart: tr.fixedStart, fixedEnd: tr.fixedEnd, startGroup: startGr, endGroup: endGr });
                //console.log("FROM: ", id, "----", tr.fixedStart ? "(start of line)" : "", tr.token, tr.fixedEnd ? "(end of line)" : "", "---> ", closureId);
                queue.unshift(closure);
            };
            for (var _i = 0, _a = trgroup.filter(function (t) { return !!t.token; }); _i < _a.length; _i++) {
                var tr = _a[_i];
                _loop_6(tr);
            }
        };
        while (queue.length) {
            _loop_5();
        }
        for (var _b = 0, states_1 = states; _b < states_1.length; _b++) {
            var state = states_1[_b];
            var charTransitions_2 = state.transitions.filter(function (t) { return typeof t.condition == "string"; }).sort(function (a, b) { return a.condition > b.condition ? 1 : -1; });
            if (charTransitions_2.length > 1) {
                var classTransitions = [];
                var condition = { fromChar: charTransitions_2[0].condition, toChar: charTransitions_2[0].condition };
                for (var i_1 = 1; i_1 <= charTransitions_2.length; i_1++) {
                    if (i_1 < charTransitions_2.length
                        && charTransitions_2[i_1].condition.charCodeAt(0) == charTransitions_2[i_1 - 1].condition.charCodeAt(0) + 1
                        && charTransitions_2[i_1].next == charTransitions_2[i_1 - 1].next
                        && charTransitions_2[i_1].fixedStart == charTransitions_2[i_1 - 1].fixedStart
                        && charTransitions_2[i_1].fixedEnd == charTransitions_2[i_1 - 1].fixedEnd
                        && charTransitions_2[i_1].final == charTransitions_2[i_1 - 1].final
                        && JSON.stringify(charTransitions_2[i_1].startGroup) == JSON.stringify(charTransitions_2[i_1 - 1].startGroup)
                        && JSON.stringify(charTransitions_2[i_1].endGroup) == JSON.stringify(charTransitions_2[i_1 - 1].endGroup)) {
                        condition.toChar = charTransitions_2[i_1].condition;
                    }
                    else {
                        if (condition.fromChar == condition.toChar) {
                            classTransitions.push(charTransitions_2[i_1 - 1]);
                        }
                        else {
                            classTransitions.push(__assign({}, charTransitions_2[i_1 - 1], { condition: condition }));
                        }
                        if (i_1 < charTransitions_2.length)
                            condition = { fromChar: charTransitions_2[i_1].condition, toChar: charTransitions_2[i_1].condition };
                    }
                }
                state.transitions = classTransitions.concat(state.transitions.filter(function (t) { return typeof t.condition != "string"; }));
            }
        }
        return states;
    };
    RegexBuilder.build = function (template) {
        var tokenTree = RegexParser.parse(template).tokenTree;
        var _a = this.convert(tokenTree), transitions = _a.transitions, nextFromState = _a.nextFromState;
        var states = this.normalize(transitions, nextFromState);
        return { states: states };
    };
    return RegexBuilder;
}());
exports.RegexBuilder = RegexBuilder;
//# sourceMappingURL=regex.js.map