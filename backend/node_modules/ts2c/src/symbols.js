"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var ctypes_1 = require("./types/ctypes");
var utils_1 = require("./types/utils");
var SymbolsHelper = /** @class */ (function () {
    function SymbolsHelper(typeChecker, typeHelper) {
        this.typeChecker = typeChecker;
        this.typeHelper = typeHelper;
        this.userStructs = {};
        this.arrayStructs = [];
        this.temporaryVariables = {
            // reserved symbols that are used in program.ts
            "main": [
                "TRUE", "FALSE", "uint8_t", "int16_t",
                "regex_indices_struct_t", "regex_match_struct_t", "regex_func_t",
                "ARRAY", "ARRAY_CREATE", "ARRAY_PUSH", "ARRAY_INSERT", "ARRAY_REMOVE", "ARRAY_POP",
                "DICT", "DICT_CREATE", "DICT_SET", "DICT_GET", "dict_find_pos", "tmp_dict_pos", "tmp_dict_pos2",
                "STR_INT16_T_BUFLEN", "str_int16_t_cmp", "str_pos", "str_rpos", "str_len",
                "str_char_code_at", "str_substring", "str_slice", "str_int16_t_cat",
                "array_int16_t_cmp", "array_str_cmp", "parse_int16_t",
                "js_var_type", "js_var", "array_js_var_t", "dict_js_var_t",
                "js_var_from", "js_var_from_int16_t", "js_var_from_uint8_t", "js_var_from_str", "js_var_from_dict",
                "str_to_int16_t", "js_var_to_str", "js_var_to_number", "js_var_to_bool", "js_var_to_undefined",
                "js_var_typeof", "js_var_dict_inc", "js_var_get", "js_var_eq", "js_var_op", "js_var_compute",
                "regex_clear_matches", "regex_match",
                "gc_main", "gc_i", "gc_j"
            ]
        };
        this.iteratorVarNames = ['i', 'j', 'k', 'l', 'm', 'n'];
        this.closureVarNames = [];
        this.scopeVarNames = [];
    }
    SymbolsHelper.prototype.getStructsAndFunctionPrototypes = function () {
        var _this = this;
        for (var _i = 0, _a = this.arrayStructs; _i < _a.length; _i++) {
            var arrElemType = _a[_i];
            var elementTypeText = this.typeHelper.getTypeString(arrElemType);
            var structName = ctypes_1.ArrayType.getArrayStructName(elementTypeText);
            this.userStructs[structName] = new ctypes_1.StructType({
                size: { type: ctypes_1.NumberVarType, order: 1 },
                capacity: { type: ctypes_1.NumberVarType, order: 2 },
                data: { type: elementTypeText + "*", order: 3 }
            });
            this.userStructs[structName].structName = structName;
        }
        var structs = Object.keys(this.userStructs).filter(function (k) { return !_this.userStructs[k].external; }).map(function (k) { return ({
            name: k,
            properties: Object.keys(_this.userStructs[k].properties).map(function (pk) { return ({
                name: pk,
                type: _this.userStructs[k].properties[pk]
            }); })
        }); });
        return [structs];
    };
    SymbolsHelper.prototype.ensureClosureStruct = function (type, parentFuncType, name) {
        if (!type.structName)
            type.structName = name + "_t";
        var params = {
            func: { type: type.getText(true), order: 0 },
            scope: { type: parentFuncType.scopeType || "void *", order: 1 }
        };
        var closureStruct = new ctypes_1.StructType(params);
        var found = this.findStructByType(closureStruct);
        if (!found)
            this.userStructs[type.structName] = closureStruct;
    };
    SymbolsHelper.prototype.ensureStruct = function (structType, name) {
        if (!structType.structName)
            structType.structName = name + "_t";
        var found = this.findStructByType(structType);
        if (!found)
            this.userStructs[structType.structName] = structType;
    };
    SymbolsHelper.prototype.ensureArrayStruct = function (elementType) {
        var _this = this;
        if (this.arrayStructs.every(function (s) { return _this.typeHelper.getTypeString(s) !== _this.typeHelper.getTypeString(elementType); }))
            this.arrayStructs.push(elementType);
    };
    SymbolsHelper.prototype.findStructByType = function (structType) {
        var userStructCode = this.getStructureBodyString(structType);
        for (var s in this.userStructs) {
            if (this.getStructureBodyString(this.userStructs[s]) == userStructCode)
                return s;
        }
        return null;
    };
    SymbolsHelper.prototype.getStructureBodyString = function (structType) {
        var userStructCode = '{\n';
        for (var propName in structType.properties) {
            var propType = structType.propertyDefs[propName].type;
            if (typeof propType === 'string') {
                userStructCode += '    ' + propType + ' ' + propName + ';\n';
            }
            else if (propType instanceof ctypes_1.ArrayType) {
                var propTypeText = propType.getText();
                if (propTypeText.indexOf("{var}") > -1)
                    userStructCode += '    ' + propTypeText.replace(/^static /, '').replace("{var}", propName) + ';\n';
                else
                    userStructCode += '    ' + propTypeText + ' ' + propName + ';\n';
            }
            else {
                userStructCode += '    ' + propType.getText() + ' ' + propName + ';\n';
            }
        }
        userStructCode += "};\n";
        return userStructCode;
    };
    /** Generate name for a new iterator variable and register it in temporaryVariables table.
     * Generated name is guarantied not to conflict with any existing names in specified scope.
     */
    SymbolsHelper.prototype.addIterator = function (scopeNode) {
        var parentFunc = utils_1.findParentFunction(scopeNode);
        var scopeId = parentFunc && parentFunc.pos + 1 || 'main';
        var existingSymbolNames = this.typeChecker.getSymbolsInScope(scopeNode, ts.SymbolFlags.Variable).map(function (s) { return s.name; });
        if (!this.temporaryVariables[scopeId])
            this.temporaryVariables[scopeId] = [];
        existingSymbolNames = existingSymbolNames.concat(this.temporaryVariables[scopeId]);
        var i = 0;
        while (i < this.iteratorVarNames.length && existingSymbolNames.indexOf(this.iteratorVarNames[i]) > -1)
            i++;
        var iteratorVarName;
        if (i == this.iteratorVarNames.length) {
            i = 2;
            while (existingSymbolNames.indexOf("i_" + i) > -1)
                i++;
            iteratorVarName = "i_" + i;
        }
        else
            iteratorVarName = this.iteratorVarNames[i];
        this.temporaryVariables[scopeId].push(iteratorVarName);
        return iteratorVarName;
    };
    /** Generate name for a new temporary variable and register it in temporaryVariables table.
     * Generated name is guarantied not to conflict with any existing names in specified scope.
     */
    SymbolsHelper.prototype.addTemp = function (scopeNode, proposedName, reserve) {
        if (reserve === void 0) { reserve = true; }
        var parentFunc = utils_1.findParentFunction(scopeNode);
        var scopeId = parentFunc && parentFunc.pos + 1 || 'main';
        var existingSymbolNames = scopeNode == null ? [] : this.typeChecker.getSymbolsInScope(scopeNode, ts.SymbolFlags.Variable).map(function (s) { return s.name; });
        if (!this.temporaryVariables[scopeId])
            this.temporaryVariables[scopeId] = [];
        existingSymbolNames = existingSymbolNames.concat(this.temporaryVariables[scopeId]);
        if (existingSymbolNames.indexOf(proposedName) > -1) {
            var i_1 = 2;
            while (existingSymbolNames.indexOf(proposedName + "_" + i_1) > -1)
                i_1++;
            proposedName = proposedName + "_" + i_1;
        }
        if (reserve)
            this.temporaryVariables[scopeId].push(proposedName);
        return proposedName;
    };
    SymbolsHelper.prototype.getClosureVarName = function (node) {
        if (!this.closureVarNames[node.pos]) {
            var name_1 = this.addTemp(node, "closure");
            this.closureVarNames[node.pos] = name_1;
        }
        return this.closureVarNames[node.pos];
    };
    SymbolsHelper.prototype.getScopeVarName = function (node) {
        if (!this.scopeVarNames[node.pos]) {
            var name_2 = this.addTemp(node, "scope");
            this.scopeVarNames[node.pos] = name_2;
        }
        return this.scopeVarNames[node.pos];
    };
    return SymbolsHelper;
}());
exports.SymbolsHelper = SymbolsHelper;
//# sourceMappingURL=symbols.js.map