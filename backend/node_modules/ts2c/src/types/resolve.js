"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var standard_1 = require("../standard");
var utils_1 = require("./utils");
var ctypes_1 = require("./ctypes");
var findcircular_1 = require("./findcircular");
var TypeResolver = /** @class */ (function () {
    function TypeResolver(typeChecker, allNodes, typeHelper, typeMerger, typeOfNodeDict) {
        this.typeChecker = typeChecker;
        this.allNodes = allNodes;
        this.typeHelper = typeHelper;
        this.typeMerger = typeMerger;
        this.typeOfNodeDict = typeOfNodeDict;
    }
    /** Postprocess TypeScript AST for better type inference and map TS types to C types */
    /** Creates typeOfNodeDict that is later used in getCType */
    TypeResolver.prototype.inferTypes = function () {
        var _this = this;
        var finder = new findcircular_1.CircularTypesFinder(this.allNodes, this.typeChecker);
        var circularAssignments = finder.findCircularAssignments();
        var type = function (t) { return ({ getType: typeof (t) === "string" ? function (_) { return t; } : t }); };
        var struct = function (prop, pos, elemType, recursive) {
            if (elemType === void 0) { elemType = ctypes_1.PointerVarType; }
            if (recursive === void 0) { recursive = false; }
            return new ctypes_1.StructType((_a = {}, _a[prop] = { type: elemType, order: pos, recursive: recursive }, _a));
            var _a;
        };
        var typeEqualities = [];
        var addEquality = function (typeGuard, node1, node2) {
            if (typeof node2 == "function")
                typeEqualities.push([typeGuard, node1, { getNode: node2 }]);
            else
                typeEqualities.push([typeGuard, node1, node2]);
        };
        // left hand side
        addEquality(ts.isIdentifier, function (n) { return n; }, function (n) { return _this.typeHelper.getDeclaration(n); });
        addEquality(ts.isPropertyAssignment, function (n) { return n; }, function (n) { return n.initializer; });
        addEquality(ts.isPropertyAssignment, function (n) { return n.parent; }, type(function (n) {
            var propName = (ts.isIdentifier(n.name) || utils_1.isStringLiteralAsIdentifier(n.name)) && n.name.text;
            if (propName)
                return struct(propName, n.pos, _this.typeHelper.getCType(n) || ctypes_1.PointerVarType);
            else
                return new ctypes_1.DictType(_this.typeHelper.getCType(n));
        }));
        addEquality(ts.isPropertyAssignment, function (n) { return n; }, type(function (n) {
            var propName = (ts.isIdentifier(n.name) || utils_1.isStringLiteralAsIdentifier(n.name)) && n.name.text;
            var type = _this.typeHelper.getCType(n.parent);
            return type instanceof ctypes_1.StructType ? type.properties[propName]
                : type instanceof ctypes_1.DictType ? type.elementType
                    : null;
        }));
        addEquality(ts.isPropertyAssignment, function (n) { return n; }, type(function (n) {
            var type = _this.typeHelper.getCType(n.initializer);
            if (type instanceof ctypes_1.FuncType && type.closureParams.length)
                return new ctypes_1.FuncType({ needsClosureStruct: true });
            else
                return null;
        }));
        addEquality(ts.isPropertyAccessExpression, function (n) { return n; }, function (n) { return n.name; });
        addEquality(utils_1.isFieldPropertyAccess, function (n) { return n.expression; }, type(function (n) { return struct(n.name.getText(), n.pos, _this.typeHelper.getCType(n) || ctypes_1.PointerVarType); }));
        addEquality(utils_1.isFieldPropertyAccess, function (n) { return n; }, type(function (n) {
            var type = _this.typeHelper.getCType(n.expression);
            return type instanceof ctypes_1.StructType ? type.properties[n.name.getText()]
                : type instanceof ctypes_1.ArrayType && n.name.getText() == "length" ? ctypes_1.NumberVarType
                    : type === ctypes_1.StringVarType && n.name.getText() == "length" ? ctypes_1.NumberVarType
                        : type instanceof ctypes_1.ArrayType || type instanceof ctypes_1.DictType ? type.elementType
                            : type === ctypes_1.UniversalVarType && n.name.getText() == "length" ? ctypes_1.NumberVarType
                                : type === ctypes_1.UniversalVarType ? ctypes_1.UniversalVarType
                                    : null;
        }));
        addEquality(utils_1.isFieldElementAccess, function (n) { return n.expression; }, type(function (n) {
            var type = _this.typeHelper.getCType(n.argumentExpression);
            var elementType = _this.typeHelper.getCType(n) || ctypes_1.PointerVarType;
            return utils_1.isStringLiteralAsIdentifier(n.argumentExpression) ? struct(n.argumentExpression.text, n.pos, elementType)
                : ts.isNumericLiteral(n.argumentExpression) ? new ctypes_1.ArrayType(elementType, 0, false)
                    : type == ctypes_1.NumberVarType ? new ctypes_1.ArrayType(elementType, 0, false)
                        : type == ctypes_1.StringVarType ? new ctypes_1.DictType(elementType)
                            : null;
        }));
        addEquality(utils_1.isFieldElementAccess, function (n) { return n; }, type(function (n) {
            var type = _this.typeHelper.getCType(n.expression);
            return ts.isStringLiteral(n.argumentExpression) && type instanceof ctypes_1.StructType ? type.properties[n.argumentExpression.getText().slice(1, -1)]
                : ts.isStringLiteral(n.argumentExpression) && type instanceof ctypes_1.ArrayType && n.argumentExpression.getText().slice(1, -1) == "length" ? ctypes_1.NumberVarType
                    : ts.isStringLiteral(n.argumentExpression) && type === ctypes_1.StringVarType && n.argumentExpression.getText().slice(1, -1) == "length" ? ctypes_1.NumberVarType
                        : ts.isStringLiteral(n.argumentExpression) && type === ctypes_1.UniversalVarType && n.argumentExpression.getText().slice(1, -1) == "length" ? ctypes_1.NumberVarType
                            : type instanceof ctypes_1.ArrayType || type instanceof ctypes_1.DictType ? type.elementType
                                : type === ctypes_1.UniversalVarType ? ctypes_1.UniversalVarType
                                    : null;
        }));
        var _loop_1 = function (i_1) {
            addEquality(ts.isArrayLiteralExpression, function (n) { return n; }, type(function (n) {
                var elemType = _this.typeHelper.getCType(n.elements[i_1]);
                return elemType ? new ctypes_1.ArrayType(elemType, 0, false) : null;
            }));
            addEquality(ts.isArrayLiteralExpression, function (n) { return n.elements[i_1]; }, type(function (n) {
                var arrType = _this.typeHelper.getCType(n);
                return arrType && arrType instanceof ctypes_1.ArrayType ? arrType.elementType
                    : arrType === ctypes_1.UniversalVarType ? ctypes_1.UniversalVarType
                        : null;
            }));
        };
        for (var i_1 = 0; i_1 < 10; i_1++) {
            _loop_1(i_1);
        }
        // expressions
        addEquality(utils_1.isEqualsExpression, function (n) { return n.left; }, function (n) { return circularAssignments[n.pos] ? null : n.right; });
        addEquality(utils_1.isEqualsExpression, function (n) { return n.left; }, type(function (n) {
            var type = _this.typeHelper.getCType(n.right);
            if (type instanceof ctypes_1.FuncType && type.closureParams.length)
                return new ctypes_1.FuncType({ needsClosureStruct: true });
            else
                return null;
        }));
        addEquality(utils_1.isFieldAssignment, function (n) { return n.left.expression; }, type(function (n) {
            if (!circularAssignments[n.pos])
                return null;
            return utils_1.isFieldElementAccess(n.left) ? struct(n.left.argumentExpression.getText().slice(1, -1), n.left.pos, ctypes_1.PointerVarType, true)
                : utils_1.isFieldPropertyAccess(n.left) ? struct(n.left.name.text, n.left.pos, ctypes_1.PointerVarType, true)
                    : null;
        }));
        addEquality(ts.isConditionalExpression, function (n) { return n.whenTrue; }, function (n) { return n.whenFalse; });
        addEquality(ts.isConditionalExpression, function (n) { return n; }, function (n) { return n.whenTrue; });
        addEquality(utils_1.isUnaryExpression, function (n) { return n; }, type(function (n) { return utils_1.getUnaryExprResultType(n.operator, _this.typeHelper.getCType(n.operand)); }));
        addEquality(utils_1.isUnaryExpression, function (n) { return n.operand; }, type(function (n) {
            if (n.operator !== ts.SyntaxKind.PlusPlusToken && n.operator !== ts.SyntaxKind.MinusMinusToken)
                return null;
            var resultType = _this.typeHelper.getCType(n);
            var accessObjType = (ts.isPropertyAccessExpression(n.operand) || ts.isElementAccessExpression(n.operand)) && _this.typeHelper.getCType(n.operand.expression);
            var isDictAccessor = accessObjType instanceof ctypes_1.DictType;
            if (resultType == ctypes_1.UniversalVarType || utils_1.toNumberCanBeNaN(resultType) || isDictAccessor)
                return ctypes_1.UniversalVarType;
            else
                return null;
        }));
        addEquality(ts.isBinaryExpression, function (n) { return n; }, type(function (n) { return utils_1.getBinExprResultType(_this.typeMerger.mergeTypes.bind(_this.typeMerger), _this.typeHelper.getCType(n.left), n.operatorToken.kind, _this.typeHelper.getCType(n.right)); }));
        addEquality(ts.isBinaryExpression, function (n) { return n.left; }, type(function (n) {
            var resultType = _this.typeHelper.getCType(n);
            var operandType = _this.typeHelper.getCType(n.left);
            var rightType = _this.typeHelper.getCType(n.right);
            if (resultType === ctypes_1.UniversalVarType) {
                return utils_1.isCompoundAssignment(n.operatorToken) ? ctypes_1.UniversalVarType
                    : operandType instanceof ctypes_1.ArrayType ? new ctypes_1.ArrayType(ctypes_1.UniversalVarType, 0, true)
                        : operandType instanceof ctypes_1.StructType || operandType instanceof ctypes_1.DictType ? new ctypes_1.DictType(ctypes_1.UniversalVarType)
                            : null;
            }
            else if (utils_1.operandsToNumber(operandType, n.operatorToken.kind, rightType) && utils_1.toNumberCanBeNaN(operandType))
                return ctypes_1.UniversalVarType;
            else
                return null;
        }));
        addEquality(ts.isBinaryExpression, function (n) { return n.right; }, type(function (n) {
            var resultType = _this.typeHelper.getCType(n);
            var operandType = _this.typeHelper.getCType(n.right);
            var leftType = _this.typeHelper.getCType(n.left);
            if (resultType === ctypes_1.UniversalVarType && !utils_1.isLogicOp(n.operatorToken.kind)) {
                return operandType instanceof ctypes_1.ArrayType ? new ctypes_1.ArrayType(ctypes_1.UniversalVarType, 0, true)
                    : operandType instanceof ctypes_1.StructType || operandType instanceof ctypes_1.DictType ? new ctypes_1.DictType(ctypes_1.UniversalVarType)
                        : null;
            }
            else if (utils_1.operandsToNumber(leftType, n.operatorToken.kind, operandType) && utils_1.toNumberCanBeNaN(operandType))
                return ctypes_1.UniversalVarType;
            else
                return null;
        }));
        addEquality(utils_1.isNullOrUndefinedOrNaN, function (n) { return n; }, type(ctypes_1.UniversalVarType));
        addEquality(ts.isParenthesizedExpression, function (n) { return n; }, function (n) { return n.expression; });
        addEquality(ts.isVoidExpression, function (n) { return n; }, type(ctypes_1.UniversalVarType));
        addEquality(ts.isVoidExpression, function (n) { return n.expression; }, type(ctypes_1.PointerVarType));
        addEquality(ts.isTypeOfExpression, function (n) { return n; }, type(ctypes_1.StringVarType));
        addEquality(utils_1.isDeleteExpression, function (n) { return n; }, type(ctypes_1.BooleanVarType));
        addEquality(utils_1.isDeleteExpression, function (n) { return n.expression.expression; }, type(function (n) { return new ctypes_1.DictType(ctypes_1.UniversalVarType); }));
        // functions
        addEquality(ts.isCallExpression, function (n) { return n.expression; }, function (n) { return _this.typeHelper.getDeclaration(n); });
        addEquality(ts.isCallExpression, function (n) { return n.expression; }, type(function (n) { return _this.typeHelper.getCType(n) ? new ctypes_1.FuncType({ returnType: _this.typeHelper.getCType(n), parameterTypes: n.arguments.map(function (arg) { return _this.typeHelper.getCType(arg); }) }) : null; }));
        addEquality(ts.isCallExpression, function (n) { return n; }, type(function (n) { return ctypes_1.FuncType.getReturnType(_this.typeHelper, n.expression); }));
        addEquality(ts.isParameter, function (n) { return n; }, function (n) { return n.name; });
        addEquality(ts.isParameter, function (n) { return n; }, function (n) { return n.initializer; });
        addEquality(ts.isNewExpression, function (n) { return n; }, type(function (n) {
            return ts.isIdentifier(n.expression) && n.expression.text === "Object" ? new ctypes_1.StructType({})
                : ctypes_1.FuncType.getInstanceType(_this.typeHelper, n.expression);
        }));
        var _loop_2 = function (i_2) {
            addEquality(ts.isNewExpression, function (n) { return n.arguments[i_2]; }, function (n) {
                var func = _this.typeHelper.getDeclaration(n.expression);
                return func && ts.isFunctionDeclaration(func) ? func.parameters[i_2] : null;
            });
        };
        for (var i_2 = 0; i_2 < 10; i_2++) {
            _loop_2(i_2);
        }
        addEquality(utils_1.isThisKeyword, function (n) { return utils_1.findParentFunction(n); }, type(function (n) { return new ctypes_1.FuncType({ instanceType: _this.typeHelper.getCType(n) }); }));
        addEquality(utils_1.isThisKeyword, function (n) { return n; }, type(function (n) { return ctypes_1.FuncType.getInstanceType(_this.typeHelper, utils_1.findParentFunction(n)); }));
        addEquality(utils_1.isMethodCall, function (n) { return n.expression.expression; }, type(function (n) { return standard_1.StandardCallHelper.getObjectType(_this.typeHelper, n); }));
        addEquality(ts.isCallExpression, function (n) { return n; }, type(function (n) { return standard_1.StandardCallHelper.getReturnType(_this.typeHelper, n); }));
        var _loop_3 = function (i_3) {
            addEquality(ts.isCallExpression, function (n) { return n.arguments[i_3]; }, type(function (n) { return utils_1.isLiteral(n.arguments[i_3]) ? null : standard_1.StandardCallHelper.getArgumentTypes(_this.typeHelper, n)[i_3]; }));
        };
        for (var i_3 = 0; i_3 < 10; i_3++) {
            _loop_3(i_3);
        }
        // crutch for callback argument type in foreach
        addEquality(utils_1.isFunctionArgInMethodCall, function (n) { return n.parameters[0]; }, type(function (n) {
            var objType = _this.typeHelper.getCType(n.parent.expression.expression);
            return objType instanceof ctypes_1.ArrayType && n.parent.expression.name.text == "forEach" ? objType.elementType : null;
        }));
        addEquality(utils_1.isFunction, function (n) { return n; }, type(function (n) { return new ctypes_1.FuncType({ parameterTypes: n.parameters.map(function (p) { return _this.typeHelper.getCType(p); }) }); }));
        var _loop_4 = function (i_4) {
            addEquality(utils_1.isFunction, function (n) { return n.parameters[i_4]; }, type(function (n) {
                var type = _this.typeHelper.getCType(n);
                return type instanceof ctypes_1.FuncType ? type.parameterTypes[i_4] : null;
            }));
        };
        for (var i_4 = 0; i_4 < 10; i_4++) {
            _loop_4(i_4);
        }
        // closures
        addEquality(utils_1.isFunction, function (n) { return n; }, type(function (node) {
            var funcsInFunction = utils_1.getAllFunctionNodesInFunction(node);
            var scopePropDefs = {};
            for (var _i = 0, funcsInFunction_1 = funcsInFunction; _i < funcsInFunction_1.length; _i++) {
                var f = funcsInFunction_1[_i];
                var fType = _this.typeHelper.getCType(f);
                if (fType && fType.needsClosureStruct && fType.closureParams) {
                    for (var _a = 0, _b = fType.closureParams; _a < _b.length; _a++) {
                        var p = _b[_a];
                        var decl = _this.typeHelper.getDeclaration(p.node);
                        scopePropDefs[p.node.text] = { type: _this.typeHelper.getCType(p.node) || ctypes_1.PointerVarType, pos: decl.pos };
                        if (utils_1.findParentFunction(decl) === node)
                            _this.typeHelper.registerScopeVariable(decl);
                    }
                }
            }
            if (Object.keys(scopePropDefs).length > 0)
                return new ctypes_1.FuncType({ scopeType: new ctypes_1.StructType(scopePropDefs) });
            else
                return null;
        }));
        addEquality(utils_1.isFunction, function (n) { return n; }, type(function (node) {
            var nodesInFunction = utils_1.getAllNodesUnder(node);
            var closureParams = [];
            nodesInFunction.filter(function (n) { return ts.isIdentifier(n); })
                .forEach(function (ident) {
                var identDecl = _this.typeHelper.getDeclaration(ident);
                // if declaration of identifier is function (i.e. function param), and it is not under node
                // (then it is defined in a parent func obviously), then add closure params of this parent function
                if (identDecl && utils_1.isFunction(identDecl) && !utils_1.isUnder(node, identDecl)) {
                    var identDeclType = _this.typeHelper.getCType(identDecl);
                    var _loop_5 = function (param) {
                        if (!closureParams.some(function (p) { return p.node.text === param.node.text; }))
                            closureParams.push(param);
                    };
                    for (var _i = 0, _a = identDeclType.closureParams; _i < _a.length; _i++) {
                        var param = _a[_i];
                        _loop_5(param);
                    }
                }
                else {
                    var identDeclFunc = identDecl && utils_1.findParentFunction(identDecl);
                    var isFieldName = ts.isPropertyAccessExpression(ident.parent) && ident.parent.name === ident;
                    var assigned = utils_1.isEqualsExpression(ident.parent) || utils_1.isCompoundAssignment(ident.parent);
                    if (identDeclFunc && identDeclFunc != node && utils_1.isUnder(identDeclFunc, node) && !isFieldName) {
                        var existing = closureParams.filter(function (p) { return p.node.escapedText === ident.escapedText; })[0];
                        if (!existing)
                            closureParams.push({ assigned: assigned, node: ident, refs: [ident] });
                        else if (assigned && !existing.assigned)
                            existing.assigned = true;
                        if (existing)
                            existing.refs.push(ident);
                    }
                }
            });
            if (closureParams.length)
                return new ctypes_1.FuncType({ closureParams: closureParams });
            else
                return null;
        }));
        // statements
        addEquality(ts.isVariableDeclaration, function (n) { return n; }, function (n) { return n.initializer; });
        addEquality(ts.isVariableDeclaration, function (n) { return n; }, type(function (n) {
            var type = _this.typeHelper.getCType(n.initializer);
            if (type instanceof ctypes_1.FuncType && type.closureParams.length)
                return new ctypes_1.FuncType({ needsClosureStruct: true });
            else
                return null;
        }));
        addEquality(utils_1.isForOfWithSimpleInitializer, function (n) { return n.expression; }, type(function (n) { return new ctypes_1.ArrayType(_this.typeHelper.getCType(n.initializer.declarations[0]) || ctypes_1.PointerVarType, 0, false); }));
        addEquality(utils_1.isForOfWithSimpleInitializer, function (n) { return n.initializer.declarations[0]; }, type(function (n) {
            var type = _this.typeHelper.getCType(n.expression);
            return type instanceof ctypes_1.ArrayType ? type.elementType : null;
        }));
        addEquality(utils_1.isForOfWithIdentifierInitializer, function (n) { return n.expression; }, type(function (n) { return new ctypes_1.ArrayType(_this.typeHelper.getCType(n.initializer) || ctypes_1.PointerVarType, 0, false); }));
        addEquality(utils_1.isForOfWithIdentifierInitializer, function (n) { return n.initializer; }, type(function (n) {
            var type = _this.typeHelper.getCType(n.expression);
            return type instanceof ctypes_1.ArrayType ? type.elementType : null;
        }));
        addEquality(ts.isForInStatement, function (n) { return n.initializer; }, type(ctypes_1.StringVarType));
        addEquality(ts.isForInStatement, function (n) { return n.expression; }, type(function (_) { return new ctypes_1.DictType(ctypes_1.PointerVarType); }));
        addEquality(ts.isReturnStatement, function (n) { return n.expression; }, type(function (n) { return ctypes_1.FuncType.getReturnType(_this.typeHelper, utils_1.findParentFunction(n)); }));
        addEquality(ts.isReturnStatement, function (n) { return utils_1.findParentFunction(n); }, type(function (n) { return _this.typeHelper.getCType(n.expression) ? new ctypes_1.FuncType({ returnType: _this.typeHelper.getCType(n.expression) }) : null; }));
        addEquality(ts.isCaseClause, function (n) { return n.expression; }, function (n) { return n.parent.parent.expression; });
        addEquality(ts.isCatchClause, function (n) { return n.variableDeclaration; }, type(ctypes_1.StringVarType));
        this.resolveTypes(typeEqualities);
    };
    TypeResolver.prototype.resolveTypes = function (typeEqualities) {
        var _this = this;
        this.allNodes.forEach(function (n) { return _this.setNodeType(n, _this.typeHelper.getCType(n)); });
        var equalities = [];
        typeEqualities.forEach(function (teq) {
            return _this.allNodes.forEach(function (node) { if (teq[0].bind(_this)(node))
                equalities.push([node, teq]); });
        });
        var changed;
        do {
            changed = false;
            for (var _i = 0, equalities_1 = equalities; _i < equalities_1.length; _i++) {
                var equality = equalities_1[_i];
                var node = equality[0], _a = equality[1], _ = _a[0], node1_func = _a[1], node2_resolver = _a[2];
                var node1 = node1_func(node);
                if (!node1)
                    continue;
                var type1 = this.typeHelper.getCType(node1);
                var node2 = node2_resolver.getNode ? node2_resolver.getNode(node) : null;
                var type2 = node2_resolver.getType ? node2_resolver.getType(node) : this.typeHelper.getCType(node2);
                if (!node2 && !type2)
                    continue;
                var _b = this.typeMerger.mergeTypes(type1, type2), type = _b.type, replaced = _b.replaced;
                if (type && replaced) {
                    if (type != type1)
                        changed = true;
                    if (node2 && type != type2)
                        changed = true;
                    this.setNodeType(node1, type);
                    if (node2)
                        this.propagateNodeType(node1, node2);
                }
            }
        } while (changed);
        for (var k in this.typeOfNodeDict) {
            var type = this.typeOfNodeDict[k].type;
            if (type instanceof ctypes_1.ArrayType && !type.isDynamicArray && type.capacity == 0)
                type.isDynamicArray = true;
            if (type instanceof ctypes_1.StructType && Object.keys(type.properties).length == 0)
                this.typeOfNodeDict[k].type = new ctypes_1.DictType(ctypes_1.PointerVarType);
        }
        this.allNodes
            .filter(function (n) { return ts.isFunctionLike(n); })
            .forEach(function (n) { return console.log(n.getText(), "|", ts.SyntaxKind[n.kind], "|", _this.typeHelper.getCType(n).getBodyText()); });
        /*
        this.allNodes
            .filter(n => !ts.isToken(n) && !ts.isBlock(n) && n.kind != ts.SyntaxKind.SyntaxList)
            .forEach(n => console.log(n.getText(), "|", ts.SyntaxKind[n.kind], "|", JSON.stringify(this.typeHelper.getCType(n))));
        */
    };
    TypeResolver.prototype.setNodeType = function (n, t) {
        if (n && t) {
            var key = n.pos + "_" + n.end;
            if (!this.typeOfNodeDict[key])
                this.typeOfNodeDict[key] = { type: t };
            else
                this.typeOfNodeDict[key].type = t;
        }
    };
    TypeResolver.prototype.propagateNodeType = function (from, to) {
        var typeToKeep = this.typeOfNodeDict[from.pos + "_" + from.end];
        var typeToRemove = this.typeOfNodeDict[to.pos + "_" + to.end];
        this.typeOfNodeDict[to.pos + "_" + to.end] = typeToRemove;
        for (var key in this.typeOfNodeDict)
            if (this.typeOfNodeDict[key] === typeToRemove)
                this.typeOfNodeDict[key] = typeToKeep;
    };
    return TypeResolver;
}());
exports.TypeResolver = TypeResolver;
//# sourceMappingURL=resolve.js.map