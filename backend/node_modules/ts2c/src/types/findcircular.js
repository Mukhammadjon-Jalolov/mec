"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var utils_1 = require("./utils");
var CircularTypesFinder = /** @class */ (function () {
    function CircularTypesFinder(allNodes, typeChecker) {
        this.allNodes = allNodes;
        this.typeChecker = typeChecker;
        this.assignments = {};
        this.circularAssignments = {};
    }
    CircularTypesFinder.prototype.findCircularAssignments = function () {
        this.circularAssignments = {};
        this.assignments = {};
        for (var _i = 0, _a = this.allNodes; _i < _a.length; _i++) {
            var node = _a[_i];
            if (utils_1.isEqualsExpression(node) || ts.isVariableDeclaration(node)) {
                var left = utils_1.isEqualsExpression(node) ? node.left : node.name;
                var right = utils_1.isEqualsExpression(node) ? node.right : node.initializer;
                if (!left || !right)
                    continue;
                var lvar = left;
                var leftProps = [];
                while (utils_1.isFieldPropertyAccess(lvar) || utils_1.isFieldElementAccess(lvar)) {
                    if (utils_1.isFieldPropertyAccess(lvar))
                        leftProps.unshift(lvar.name.text);
                    else if (utils_1.isFieldElementAccess(lvar))
                        leftProps.unshift(lvar.argumentExpression.getText().slice(1, -1));
                    lvar = lvar.expression;
                }
                this.checkOneAssignment(node, lvar, leftProps, right);
            }
        }
        console.log(Object.keys(this.circularAssignments));
        return this.circularAssignments;
    };
    CircularTypesFinder.prototype.checkOneAssignment = function (refNode, left, leftProps, right) {
        var _this = this;
        if (ts.isObjectLiteralExpression(right)) {
            for (var _i = 0, _a = right.properties; _i < _a.length; _i++) {
                var prop = _a[_i];
                if (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name))
                    this.checkOneAssignment(refNode, left, leftProps.concat(prop.name.text), prop.initializer);
            }
            return;
        }
        var rightProps = [];
        while (utils_1.isFieldPropertyAccess(right) || utils_1.isFieldElementAccess(right)) {
            if (utils_1.isFieldPropertyAccess(right))
                rightProps.unshift(right.name.text);
            else if (utils_1.isFieldElementAccess(right))
                rightProps.unshift(right.argumentExpression.getText().slice(1, -1));
            right = right.expression;
        }
        var symbolRight = this.typeChecker.getSymbolAtLocation(right);
        var symbolLeft = this.typeChecker.getSymbolAtLocation(left);
        if (symbolRight && symbolLeft) {
            var key_1 = symbolLeft.valueDeclaration.pos + "->" + leftProps.map(function (p) { return p + "->"; }).join("");
            var value_1 = symbolRight.valueDeclaration.pos + "->" + rightProps.map(function (p) { return p + "->"; }).join("");
            if (key_1.indexOf(value_1) === 0 || Object.keys(this.assignments).filter(function (k) { return k.indexOf(value_1) === 0; }).some(function (k) { return _this.assignments[k].some(function (a) { return key_1.indexOf(a) === 0; }); }))
                this.circularAssignments[refNode.pos] = { node: symbolLeft.valueDeclaration, propChain: leftProps };
            this.assignments[key_1] = (this.assignments[key_1] || []).concat(value_1);
        }
    };
    return CircularTypesFinder;
}());
exports.CircularTypesFinder = CircularTypesFinder;
//# sourceMappingURL=findcircular.js.map