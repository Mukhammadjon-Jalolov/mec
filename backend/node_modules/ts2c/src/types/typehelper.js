"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var standard_1 = require("../standard");
var ctypes_1 = require("./ctypes");
var merge_1 = require("./merge");
var resolve_1 = require("./resolve");
var utils_1 = require("./utils");
var TypeHelper = /** @class */ (function () {
    function TypeHelper(typeChecker, allNodes) {
        this.typeChecker = typeChecker;
        this.arrayLiteralsTypes = {};
        this.objectLiteralsTypes = {};
        this.typeOfNodeDict = {};
        this.typeMerger = new merge_1.TypeMerger();
        this.scopeVariables = {};
        this.typeResolver = new resolve_1.TypeResolver(typeChecker, allNodes, this, this.typeMerger, this.typeOfNodeDict);
    }
    TypeHelper.prototype.inferTypes = function () {
        this.typeResolver.inferTypes();
    };
    /** Get C type of TypeScript node */
    TypeHelper.prototype.getCType = function (node) {
        if (!node || !node.kind)
            return null;
        var found = this.typeOfNodeDict[node.pos + "_" + node.end];
        if (found)
            return found.type;
        switch (node.kind) {
            case ts.SyntaxKind.NumericLiteral:
                return ctypes_1.NumberVarType;
            case ts.SyntaxKind.TrueKeyword:
            case ts.SyntaxKind.FalseKeyword:
                return ctypes_1.BooleanVarType;
            case ts.SyntaxKind.StringLiteral:
                return ctypes_1.StringVarType;
            case ts.SyntaxKind.RegularExpressionLiteral:
                return ctypes_1.RegexVarType;
            case ts.SyntaxKind.ArrayLiteralExpression:
                {
                    if (!this.arrayLiteralsTypes[node.pos])
                        this.determineArrayType(node);
                    return this.arrayLiteralsTypes[node.pos];
                }
            case ts.SyntaxKind.ObjectLiteralExpression:
                {
                    if (!this.objectLiteralsTypes[node.pos])
                        this.objectLiteralsTypes[node.pos] = this.generateStructure(this.typeChecker.getTypeAtLocation(node));
                    return this.objectLiteralsTypes[node.pos];
                }
            case ts.SyntaxKind.CallExpression:
                {
                    var call = node;
                    var retType = standard_1.StandardCallHelper.getReturnType(this, call);
                    if (retType)
                        return retType;
                }
        }
        if (node.kind != ts.SyntaxKind.ImportClause && node.pos != -1) {
            var tsType = this.typeChecker.getTypeAtLocation(node);
            var type = tsType && this.convertType(tsType, node);
            if (type)
                return type;
        }
        return null;
    };
    /** Get textual representation of type of the parameter for inserting into the C code */
    TypeHelper.prototype.getTypeString = function (source) {
        var cType = source;
        if (source && source.flags != null && source.intrinsicName != null) // ts.Type
            cType = this.convertType(source);
        else if (source && source.flags != null && source.callSignatures != null && source.constructSignatures != null) // ts.Type
            cType = this.convertType(source);
        else if (source && source.kind != null && source.flags != null) // ts.Node
            cType = this.getCType(source);
        if (cType instanceof ctypes_1.ArrayType || cType instanceof ctypes_1.StructType || cType instanceof ctypes_1.DictType || cType instanceof ctypes_1.FuncType)
            return cType.getText();
        else if (typeof cType === 'string')
            return cType;
        else
            return "/* Cannot determine variable type from source " + (source && source.getText ? source.getText() : JSON.stringify(source)) + "*/";
    };
    TypeHelper.prototype.getDeclaration = function (n) {
        var s = this.typeChecker.getSymbolAtLocation(n);
        return s && s.valueDeclaration;
    };
    TypeHelper.prototype.registerSyntheticNode = function (n, t) {
        if (!n || !(n.flags & ts.NodeFlags.Synthesized))
            return false;
        n.end = TypeHelper.syntheticNodesCounter++;
        this.typeResolver.setNodeType(n, t);
    };
    TypeHelper.prototype.registerScopeVariable = function (decl) {
        this.scopeVariables[decl.pos] = true;
    };
    TypeHelper.prototype.isScopeVariableDeclaration = function (decl) {
        return this.scopeVariables[decl.pos] || false;
    };
    TypeHelper.prototype.isScopeVariable = function (n) {
        var decl = this.getDeclaration(n);
        return decl && this.scopeVariables[decl.pos] || false;
    };
    /** Convert ts.Type to CType */
    TypeHelper.prototype.convertType = function (tsType, node) {
        if (!tsType || tsType.flags == ts.TypeFlags.Void)
            return ctypes_1.VoidType;
        if (tsType.flags == ts.TypeFlags.String || tsType.flags == ts.TypeFlags.StringLiteral)
            return ctypes_1.StringVarType;
        if (tsType.flags == ts.TypeFlags.Number || tsType.flags == ts.TypeFlags.NumberLiteral)
            return ctypes_1.NumberVarType;
        if (tsType.flags == ts.TypeFlags.Boolean || tsType.flags == (ts.TypeFlags.Boolean + ts.TypeFlags.Union))
            return ctypes_1.BooleanVarType;
        if (tsType.flags & ts.TypeFlags.Object && tsType.getProperties().length > 0 && tsType.getProperties().every(function (s) { return /[a-zA-Z_]/.test(s.name); })) {
            var structType = this.generateStructure(tsType);
            var baseType = this.typeChecker.getBaseTypeOfLiteralType(tsType);
            var cTypeTag = baseType && baseType.symbol && baseType.symbol.getJsDocTags().filter(function (t) { return t.name == "ctype"; })[0];
            structType.forcedType = cTypeTag && cTypeTag.text.trim();
            structType.external = baseType && baseType.symbol && utils_1.findParentSourceFile(baseType.symbol.declarations[0]).isDeclarationFile;
            return structType;
        }
        return null;
    };
    TypeHelper.prototype.generateStructure = function (tsType) {
        var userStructInfo = {};
        for (var _i = 0, _a = tsType.getProperties(); _i < _a.length; _i++) {
            var prop = _a[_i];
            if (prop.name == "prototype")
                continue;
            var declaration = prop.valueDeclaration;
            var propTsType = this.typeChecker.getTypeOfSymbolAtLocation(prop, declaration);
            var propType = this.convertType(propTsType, declaration.name) || ctypes_1.PointerVarType;
            if (propType == ctypes_1.PointerVarType && ts.isPropertyAssignment(declaration)) {
                if (declaration.initializer && ts.isArrayLiteralExpression(declaration.initializer))
                    propType = this.determineArrayType(declaration.initializer);
            }
            userStructInfo[prop.name] = { type: propType, order: declaration.pos };
        }
        return this.typeMerger.ensureNoTypeDuplicates(new ctypes_1.StructType(userStructInfo));
    };
    TypeHelper.prototype.determineArrayType = function (arrLiteral) {
        var elementType = ctypes_1.PointerVarType;
        var cap = arrLiteral.elements.length;
        if (cap > 0)
            elementType = this.convertType(this.typeChecker.getTypeAtLocation(arrLiteral.elements[0])) || ctypes_1.PointerVarType;
        var type = new ctypes_1.ArrayType(elementType, cap, false);
        this.arrayLiteralsTypes[arrLiteral.pos] = type;
        return type;
    };
    TypeHelper.syntheticNodesCounter = 0;
    return TypeHelper;
}());
exports.TypeHelper = TypeHelper;
//# sourceMappingURL=typehelper.js.map