"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var ctypes_1 = require("./ctypes");
function isNode(n) {
    return n && n.kind !== undefined && n.flags !== undefined && n.pos !== undefined && n.end !== undefined;
}
exports.isNode = isNode;
function isEqualsExpression(n) {
    return n && n.kind == ts.SyntaxKind.BinaryExpression && n.operatorToken.kind == ts.SyntaxKind.EqualsToken;
}
exports.isEqualsExpression = isEqualsExpression;
function isFieldAssignment(n) {
    return n && n.kind == ts.SyntaxKind.BinaryExpression && n.operatorToken.kind == ts.SyntaxKind.EqualsToken && (isFieldElementAccess(n.left) || isFieldPropertyAccess(n.left));
}
exports.isFieldAssignment = isFieldAssignment;
function isMethodCall(n) {
    return ts.isCallExpression(n) && ts.isPropertyAccessExpression(n.expression);
}
exports.isMethodCall = isMethodCall;
function isFunction(n) {
    return ts.isFunctionDeclaration(n) || ts.isFunctionExpression(n);
}
exports.isFunction = isFunction;
function isFunctionArgInMethodCall(n) {
    return ts.isFunctionExpression(n) && ts.isCallExpression(n.parent) && n.parent.arguments[0] == n && ts.isPropertyAccessExpression(n.parent.expression);
}
exports.isFunctionArgInMethodCall = isFunctionArgInMethodCall;
function isFieldElementAccess(n) {
    return ts.isElementAccessExpression(n) && (!ts.isCallExpression(n.parent) || n.parent.expression != n);
}
exports.isFieldElementAccess = isFieldElementAccess;
function isFieldPropertyAccess(n) {
    return ts.isPropertyAccessExpression(n) && (!ts.isCallExpression(n.parent) || n.parent.expression != n);
}
exports.isFieldPropertyAccess = isFieldPropertyAccess;
function isForOfWithSimpleInitializer(n) {
    return ts.isForOfStatement(n) && ts.isVariableDeclarationList(n.initializer) && n.initializer.declarations.length == 1;
}
exports.isForOfWithSimpleInitializer = isForOfWithSimpleInitializer;
function isForOfWithIdentifierInitializer(n) {
    return ts.isForOfStatement(n) && ts.isIdentifier(n.initializer);
}
exports.isForOfWithIdentifierInitializer = isForOfWithIdentifierInitializer;
function isLiteral(n) {
    return ts.isNumericLiteral(n) || ts.isStringLiteral(n) || ts.isRegularExpressionLiteral(n) || n.kind == ts.SyntaxKind.TrueKeyword || n.kind == ts.SyntaxKind.FalseKeyword;
}
exports.isLiteral = isLiteral;
function isUnaryExpression(n) {
    return ts.isPrefixUnaryExpression(n) || ts.isPostfixUnaryExpression(n);
}
exports.isUnaryExpression = isUnaryExpression;
exports.SyntaxKind_NaNKeyword = ts.SyntaxKind.Count + 1;
function isNullOrUndefinedOrNaN(n) {
    return n.kind === ts.SyntaxKind.NullKeyword || n.kind === ts.SyntaxKind.UndefinedKeyword || n.kind === exports.SyntaxKind_NaNKeyword;
}
exports.isNullOrUndefinedOrNaN = isNullOrUndefinedOrNaN;
function isNullOrUndefined(n) {
    return n.kind === ts.SyntaxKind.NullKeyword || n.kind === ts.SyntaxKind.UndefinedKeyword;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isDeleteExpression(n) {
    return ts.isDeleteExpression(n) && (ts.isPropertyAccessExpression(n.expression) || ts.isElementAccessExpression(n.expression));
}
exports.isDeleteExpression = isDeleteExpression;
function isThisKeyword(n) {
    return n.kind === ts.SyntaxKind.ThisKeyword;
}
exports.isThisKeyword = isThisKeyword;
function isCompoundAssignment(n) {
    if (ts.isBinaryExpression(n))
        return n.operatorToken.kind >= ts.SyntaxKind.FirstCompoundAssignment && n.operatorToken.kind <= ts.SyntaxKind.LastCompoundAssignment;
    else
        return n.kind >= ts.SyntaxKind.FirstCompoundAssignment && n.kind <= ts.SyntaxKind.LastCompoundAssignment;
}
exports.isCompoundAssignment = isCompoundAssignment;
function isNumberOp(op) {
    return [
        ts.SyntaxKind.MinusToken, ts.SyntaxKind.MinusEqualsToken,
        ts.SyntaxKind.AsteriskToken, ts.SyntaxKind.AsteriskEqualsToken,
        ts.SyntaxKind.SlashToken, ts.SyntaxKind.SlashEqualsToken,
        ts.SyntaxKind.PercentToken, ts.SyntaxKind.PercentEqualsToken,
    ].indexOf(op) > -1;
}
exports.isNumberOp = isNumberOp;
function isIntegerOp(op) {
    return [
        ts.SyntaxKind.LessThanLessThanToken, ts.SyntaxKind.LessThanLessThanEqualsToken,
        ts.SyntaxKind.GreaterThanGreaterThanToken, ts.SyntaxKind.GreaterThanGreaterThanEqualsToken,
        ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
        ts.SyntaxKind.BarToken, ts.SyntaxKind.BarEqualsToken,
        ts.SyntaxKind.AmpersandToken, ts.SyntaxKind.AmpersandEqualsToken
    ].indexOf(op) > -1;
}
exports.isIntegerOp = isIntegerOp;
function isRelationalOp(op) {
    return [
        ts.SyntaxKind.LessThanToken, ts.SyntaxKind.LessThanEqualsToken,
        ts.SyntaxKind.GreaterThanToken, ts.SyntaxKind.GreaterThanEqualsToken
    ].indexOf(op) > -1;
}
exports.isRelationalOp = isRelationalOp;
function isEqualityOp(op) {
    return [
        ts.SyntaxKind.EqualsEqualsToken, ts.SyntaxKind.EqualsEqualsEqualsToken,
        ts.SyntaxKind.ExclamationEqualsToken, ts.SyntaxKind.ExclamationEqualsEqualsToken,
    ].indexOf(op) > -1;
}
exports.isEqualityOp = isEqualityOp;
function isLogicOp(op) {
    return [
        ts.SyntaxKind.BarBarToken, ts.SyntaxKind.AmpersandAmpersandToken
    ].indexOf(op) > -1;
}
exports.isLogicOp = isLogicOp;
function isPlusOp(op) {
    return op == ts.SyntaxKind.PlusToken || op == ts.SyntaxKind.PlusEqualsToken;
}
exports.isPlusOp = isPlusOp;
function isStringLiteralAsIdentifier(n) {
    return ts.isStringLiteral(n) && /^[A-Za-z_][A-Za-z_0-9]*$/.test(n.text);
}
exports.isStringLiteralAsIdentifier = isStringLiteralAsIdentifier;
function isInBoolContext(n) {
    while (ts.isBinaryExpression(n.parent) && isLogicOp(n.parent.operatorToken.kind))
        n = n.parent;
    return ts.isPrefixUnaryExpression(n.parent) && n.parent.operator === ts.SyntaxKind.ExclamationToken
        || ts.isIfStatement(n.parent) && n.parent.expression === n
        || ts.isWhileStatement(n.parent) && n.parent.expression === n
        || ts.isDoStatement(n.parent) && n.parent.expression === n
        || ts.isForStatement(n.parent) && n.parent.condition === n;
}
exports.isInBoolContext = isInBoolContext;
function isSimpleNode(n) {
    return ts.isStringLiteral(n) || ts.isNumericLiteral(n) || ts.isIdentifier(n);
}
exports.isSimpleNode = isSimpleNode;
function isSideEffectExpression(n) {
    return isEqualsExpression(n) || isCompoundAssignment(n)
        || isUnaryExpression(n) && n.operator === ts.SyntaxKind.PlusPlusToken
        || isUnaryExpression(n) && n.operator === ts.SyntaxKind.MinusMinusToken
        || ts.isCallExpression(n)
        || ts.isNewExpression(n);
}
exports.isSideEffectExpression = isSideEffectExpression;
function operandsToNumber(leftType, op, rightType) {
    return isNumberOp(op) || isIntegerOp(op)
        || op == ts.SyntaxKind.PlusToken && !toNumberCanBeNaN(leftType) && !toNumberCanBeNaN(rightType)
        || isRelationalOp(op) && (leftType !== ctypes_1.StringVarType || rightType !== ctypes_1.StringVarType);
}
exports.operandsToNumber = operandsToNumber;
function getBinExprResultType(mergeTypes, leftType, op, rightType) {
    if (op === ts.SyntaxKind.EqualsToken)
        return rightType;
    if (isRelationalOp(op) || isEqualityOp(op) || op === ts.SyntaxKind.InKeyword || op === ts.SyntaxKind.InstanceOfKeyword)
        return ctypes_1.BooleanVarType;
    if (leftType == null || rightType == null)
        return null;
    if (isLogicOp(op))
        return mergeTypes(leftType, rightType).type;
    if (isNumberOp(op) || isIntegerOp(op))
        return toNumberCanBeNaN(leftType) || toNumberCanBeNaN(rightType) ? ctypes_1.UniversalVarType : ctypes_1.NumberVarType;
    if (op === ts.SyntaxKind.PlusToken || op === ts.SyntaxKind.PlusEqualsToken)
        return leftType === ctypes_1.UniversalVarType || rightType === ctypes_1.UniversalVarType ? ctypes_1.UniversalVarType
            : toPrimitive(leftType) === ctypes_1.StringVarType || toPrimitive(rightType) === ctypes_1.StringVarType ? ctypes_1.StringVarType
                : toPrimitive(leftType) === ctypes_1.NumberVarType && toPrimitive(rightType) == ctypes_1.NumberVarType ? ctypes_1.NumberVarType
                    : null;
    console.log("WARNING: unexpected binary expression!");
    return null;
}
exports.getBinExprResultType = getBinExprResultType;
function getUnaryExprResultType(op, operandType) {
    if (op === ts.SyntaxKind.ExclamationToken) {
        return ctypes_1.BooleanVarType;
    }
    else if (op === ts.SyntaxKind.TildeToken) {
        return ctypes_1.NumberVarType;
    }
    else {
        return toNumberCanBeNaN(operandType) ? ctypes_1.UniversalVarType : ctypes_1.NumberVarType;
    }
}
exports.getUnaryExprResultType = getUnaryExprResultType;
function toNumberCanBeNaN(t) {
    return t !== null && t !== ctypes_1.PointerVarType && t !== ctypes_1.NumberVarType && t !== ctypes_1.BooleanVarType && !(t instanceof ctypes_1.ArrayType && !t.isDynamicArray && t.capacity == 1 && !toNumberCanBeNaN(t.elementType));
}
exports.toNumberCanBeNaN = toNumberCanBeNaN;
function toPrimitive(t) {
    return t === null || t === ctypes_1.PointerVarType ? t : t === ctypes_1.NumberVarType || t === ctypes_1.BooleanVarType ? ctypes_1.NumberVarType : ctypes_1.StringVarType;
}
exports.toPrimitive = toPrimitive;
function findParentFunction(node) {
    var parentFunc = node;
    while (parentFunc && !isFunction(parentFunc))
        parentFunc = parentFunc.parent;
    return parentFunc;
}
exports.findParentFunction = findParentFunction;
function findParentSourceFile(node) {
    var parent = node;
    while (!ts.isSourceFile(parent))
        parent = parent.parent;
    return parent;
}
exports.findParentSourceFile = findParentSourceFile;
function getAllFunctionNodesInFunction(node) {
    var nodes = node.getChildren().slice();
    var foundFuncNodes = [];
    var cur;
    while (cur = nodes.shift()) {
        if (ts.isFunctionLike(cur)) {
            foundFuncNodes.push(cur);
        }
        else
            nodes.push.apply(nodes, cur.getChildren());
    }
    return foundFuncNodes;
}
exports.getAllFunctionNodesInFunction = getAllFunctionNodesInFunction;
function getAllNodesInFunction(node) {
    var i = 0;
    var nodes = node.getChildren();
    while (i < nodes.length) {
        if (ts.isFunctionLike(nodes[i]))
            i++;
        else
            nodes.push.apply(nodes, nodes[i++].getChildren());
    }
    return nodes;
}
exports.getAllNodesInFunction = getAllNodesInFunction;
function getAllNodesUnder(node) {
    var i = 0;
    var nodes = [node];
    while (i < nodes.length)
        nodes.push.apply(nodes, nodes[i++].getChildren());
    return nodes;
}
exports.getAllNodesUnder = getAllNodesUnder;
function isUnder(container, item) {
    var parent = item;
    while (parent && parent != container)
        parent = parent.parent;
    return parent;
}
exports.isUnder = isUnder;
function hasType(refType, type) {
    return refType == type
        || refType instanceof ctypes_1.StructType && Object.keys(refType.properties).some(function (k) { return hasType(refType.properties[k], type); })
        || refType instanceof ctypes_1.ArrayType && hasType(refType.elementType, type)
        || refType instanceof ctypes_1.DictType && hasType(refType.elementType, type)
        || refType instanceof ctypes_1.FuncType && hasType(refType.returnType, type)
        || refType instanceof ctypes_1.FuncType && hasType(refType.instanceType, type)
        || refType instanceof ctypes_1.FuncType && refType.parameterTypes.some(function (pt) { return hasType(pt, type); });
}
exports.hasType = hasType;
//# sourceMappingURL=utils.js.map