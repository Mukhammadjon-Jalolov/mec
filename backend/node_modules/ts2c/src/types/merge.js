"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ctypes_1 = require("./ctypes");
var TypeMerger = /** @class */ (function () {
    function TypeMerger() {
        this.typesDict = {};
    }
    TypeMerger.prototype.mergeTypes = function (type1, type2) {
        var type1_result = { type: this.ensureNoTypeDuplicates(type1), replaced: true };
        var type2_result = { type: this.ensureNoTypeDuplicates(type2), replaced: true };
        var noChanges = { type: this.ensureNoTypeDuplicates(type1), replaced: false };
        if (!type1 && type2)
            return type2_result;
        else if (type1 && !type2)
            return type1_result;
        else if (!type1 && !type2)
            return noChanges;
        else if (typeof type1 == "string" && typeof type2 == "string" && type1 == type2)
            return noChanges;
        else if (type1 === ctypes_1.VoidType)
            return type2_result;
        else if (type2 === ctypes_1.VoidType)
            return type1_result;
        else if (type1 === ctypes_1.PointerVarType)
            return type2_result;
        else if (type2 === ctypes_1.PointerVarType)
            return type1_result;
        else if (type1 === ctypes_1.UniversalVarType)
            return type1_result;
        else if (type2 === ctypes_1.UniversalVarType)
            return type2_result;
        else if (type1 === ctypes_1.StringVarType && type2 instanceof ctypes_1.StructType) {
            if (Object.keys(type2.properties).length == 1 && (type2.properties["length"] == ctypes_1.PointerVarType || type2.properties["length"] == ctypes_1.NumberVarType))
                return type1_result;
        }
        else if (type1 instanceof ctypes_1.StructType && type2 === ctypes_1.StringVarType) {
            if (Object.keys(type1.properties).length == 1 && (type1.properties["length"] == ctypes_1.PointerVarType || type1.properties["length"] == ctypes_1.NumberVarType))
                return type2_result;
        }
        else if (type1 instanceof ctypes_1.ArrayType && type2 instanceof ctypes_1.ArrayType) {
            var cap = Math.max(type2.capacity, type1.capacity);
            var isDynamicArray = type2.isDynamicArray || type1.isDynamicArray;
            var elementTypeMergeResult = this.mergeTypes(type1.elementType, type2.elementType);
            if (type1.capacity != cap || type2.capacity != cap
                || type1.isDynamicArray != isDynamicArray || type2.isDynamicArray != isDynamicArray
                || elementTypeMergeResult.replaced)
                return { type: this.ensureNoTypeDuplicates(new ctypes_1.ArrayType(elementTypeMergeResult.type, cap, isDynamicArray)), replaced: true };
            return noChanges;
        }
        else if (type1 instanceof ctypes_1.DictType && type2 instanceof ctypes_1.ArrayType) {
            return type1_result;
        }
        else if (type1 instanceof ctypes_1.ArrayType && type2 instanceof ctypes_1.DictType) {
            return type2_result;
        }
        else if (type1 instanceof ctypes_1.StructType && type2 instanceof ctypes_1.StructType) {
            var props = Object.keys(type1.properties).concat(Object.keys(type2.properties));
            var changed = false;
            var newProps = {};
            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
                var p = props_1[_i];
                var recursive1 = type1.propertyDefs[p] ? type1.propertyDefs[p].recursive : false;
                var recursive2 = type2.propertyDefs[p] ? type2.propertyDefs[p].recursive : false;
                var result = recursive1 || recursive2 ? { type: ctypes_1.PointerVarType, replaced: recursive1 != recursive2 } : this.mergeTypes(type1.properties[p], type2.properties[p]);
                var order = Math.max(type1.propertyDefs[p] ? type1.propertyDefs[p].order : 0, type2.propertyDefs[p] ? type2.propertyDefs[p].order : 0);
                newProps[p] = { type: result.type, order: order, recursive: recursive1 || recursive2 };
                if (result.replaced)
                    changed = true;
            }
            return changed ? { type: this.ensureNoTypeDuplicates(new ctypes_1.StructType(newProps)), replaced: true } : noChanges;
        }
        else if (type1 instanceof ctypes_1.ArrayType && type2 instanceof ctypes_1.StructType) {
            return this.mergeArrayAndStruct(type1, type2);
        }
        else if (type1 instanceof ctypes_1.StructType && type2 instanceof ctypes_1.ArrayType) {
            return this.mergeArrayAndStruct(type2, type1);
        }
        else if (type1 instanceof ctypes_1.DictType && type2 instanceof ctypes_1.StructType) {
            return this.mergeDictAndStruct(type1, type2);
        }
        else if (type1 instanceof ctypes_1.StructType && type2 instanceof ctypes_1.DictType) {
            return this.mergeDictAndStruct(type2, type1);
        }
        else if (type1 instanceof ctypes_1.DictType && type2 instanceof ctypes_1.DictType) {
            var _a = this.mergeTypes(type1.elementType, type2.elementType), elemType = _a.type, replaced = _a.replaced;
            if (replaced)
                return { type: this.ensureNoTypeDuplicates(new ctypes_1.DictType(elemType)), replaced: true };
            else
                return noChanges;
        }
        else if (type1 instanceof ctypes_1.FuncType && type2 instanceof ctypes_1.FuncType) {
            var _b = this.mergeTypes(type1.returnType, type2.returnType), returnType = _b.type, returnTypeReplaced = _b.replaced;
            var _c = this.mergeTypes(type1.instanceType, type2.instanceType), instanceType = _c.type, instanceTypeReplaced = _c.replaced;
            var _d = this.mergeTypes(type1.scopeType, type2.scopeType), scopeType = _d.type, scopeTypeReplaced = _d.replaced;
            var paramCount = Math.max(type1.parameterTypes.length, type2.parameterTypes.length);
            var paramTypesReplaced = type1.parameterTypes.length !== type2.parameterTypes.length;
            var parameterTypes = [];
            for (var i_1 = 0; i_1 < paramCount; i_1++) {
                var _e = this.mergeTypes(type1.parameterTypes[i_1], type2.parameterTypes[i_1]), pType = _e.type, pTypeReplaced = _e.replaced;
                parameterTypes.push(pType);
                if (pTypeReplaced)
                    paramTypesReplaced = true;
            }
            var closureParamCount = Math.max(type1.closureParams.length, type2.closureParams.length);
            var closureParamsReplaced = type1.closureParams.length !== type2.closureParams.length;
            var closureParams = [];
            for (var i_2 = 0; i_2 < closureParamCount; i_2++) {
                closureParams.push(type1.closureParams[i_2] || type2.closureParams[i_2]);
            }
            var needsClosureStructReplaced = type1.needsClosureStruct != type2.needsClosureStruct;
            var needsClosureStruct = type1.needsClosureStruct || type2.needsClosureStruct;
            if (returnTypeReplaced || instanceTypeReplaced || scopeTypeReplaced || paramTypesReplaced || closureParamsReplaced || needsClosureStructReplaced)
                return { type: this.ensureNoTypeDuplicates(new ctypes_1.FuncType({ returnType: returnType, parameterTypes: parameterTypes, instanceType: instanceType, closureParams: closureParams, needsClosureStruct: needsClosureStruct, scopeType: scopeType })), replaced: true };
            else
                return noChanges;
        }
        else
            return { type: ctypes_1.UniversalVarType, replaced: true };
    };
    TypeMerger.prototype.mergeArrayAndStruct = function (arrayType, structType) {
        var props = Object.keys(structType.properties);
        var needPromoteToDictionary = false;
        var needPromoteToTuple = false;
        for (var _i = 0, props_2 = props; _i < props_2.length; _i++) {
            var p = props_2[_i];
            if (p == "length")
                continue;
            if (isNaN(+p))
                needPromoteToDictionary = true;
            if (this.mergeTypes(arrayType.elementType, structType.properties[p]).replaced)
                needPromoteToTuple = true;
        }
        if (needPromoteToDictionary && needPromoteToTuple)
            return { type: this.ensureNoTypeDuplicates(new ctypes_1.DictType(ctypes_1.UniversalVarType)), replaced: true };
        else if (needPromoteToDictionary)
            return { type: this.ensureNoTypeDuplicates(new ctypes_1.DictType(arrayType.elementType)), replaced: true };
        else if (needPromoteToTuple)
            return { type: this.ensureNoTypeDuplicates(new ctypes_1.ArrayType(ctypes_1.UniversalVarType, arrayType.capacity, arrayType.isDynamicArray)), replaced: true };
        else
            return { type: arrayType, replaced: true };
    };
    TypeMerger.prototype.mergeDictAndStruct = function (dictType, structType) {
        var elementType = dictType.elementType;
        for (var k in structType.properties)
            (elementType = this.mergeTypes(elementType, structType.properties[k]).type);
        return { type: this.ensureNoTypeDuplicates(new ctypes_1.DictType(elementType)), replaced: true };
    };
    TypeMerger.prototype.ensureNoTypeDuplicates = function (t) {
        if (!t)
            return null;
        var typeBodyText = ctypes_1.getTypeBodyText(t);
        var type = this.typesDict[typeBodyText];
        if (type instanceof ctypes_1.ArrayType)
            type.capacity = Math.max(type.capacity, t.capacity);
        if (type instanceof ctypes_1.StructType)
            for (var pk in type.propertyDefs)
                type.propertyDefs[pk].recursive = type.propertyDefs[pk].recursive || t.propertyDefs[pk].recursive;
        if (!type)
            type = this.typesDict[typeBodyText] = t;
        return type;
    };
    return TypeMerger;
}());
exports.TypeMerger = TypeMerger;
//# sourceMappingURL=merge.js.map