"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var template_1 = require("../template");
var ctypes_1 = require("../types/ctypes");
var assignment_1 = require("./assignment");
var utils_1 = require("../types/utils");
var CVariableStatement = /** @class */ (function (_super) {
    __extends(CVariableStatement, _super);
    function CVariableStatement(scope, node) {
        var _this = _super.call(this) || this;
        _this.declarations = node.declarationList.declarations.map(function (d) { return template_1.CodeTemplateFactory.createForNode(scope, d); });
        return _this;
    }
    CVariableStatement = __decorate([
        template_1.CodeTemplate("{declarations}", ts.SyntaxKind.VariableStatement)
    ], CVariableStatement);
    return CVariableStatement;
}(template_1.CTemplateBase));
exports.CVariableStatement = CVariableStatement;
var CVariableDeclarationList = /** @class */ (function (_super) {
    __extends(CVariableDeclarationList, _super);
    function CVariableDeclarationList(scope, node) {
        var _this = _super.call(this) || this;
        _this.declarations = node.declarations.map(function (d) { return template_1.CodeTemplateFactory.createForNode(scope, d); });
        return _this;
    }
    CVariableDeclarationList = __decorate([
        template_1.CodeTemplate("{declarations}", ts.SyntaxKind.VariableDeclarationList)
    ], CVariableDeclarationList);
    return CVariableDeclarationList;
}(template_1.CTemplateBase));
exports.CVariableDeclarationList = CVariableDeclarationList;
var CVariableDeclaration = /** @class */ (function (_super) {
    __extends(CVariableDeclaration, _super);
    function CVariableDeclaration(scope, varDecl) {
        var _this = _super.call(this) || this;
        _this.allocator = '';
        _this.initializer = '';
        var name = varDecl.name.getText();
        var type = scope.root.typeHelper.getCType(varDecl.name);
        var scopeVar = scope.root.typeHelper.isScopeVariableDeclaration(varDecl);
        if (type instanceof ctypes_1.ArrayType && !type.isDynamicArray && ts.isArrayLiteralExpression(varDecl.initializer) && !scopeVar) {
            var canUseInitializerList = varDecl.initializer.elements.every(function (e) { return e.kind == ts.SyntaxKind.NumericLiteral || e.kind == ts.SyntaxKind.StringLiteral; });
            if (canUseInitializerList) {
                var s = "{ ";
                for (var i_1 = 0; i_1 < type.capacity; i_1++) {
                    if (i_1 != 0)
                        s += ", ";
                    var cExpr = template_1.CodeTemplateFactory.createForNode(scope, varDecl.initializer.elements[i_1]);
                    s += typeof cExpr === 'string' ? cExpr : cExpr.resolve();
                }
                s += " }";
                scope.variables.push(new CVariable(scope, name, type, { initializer: s }));
                return _this;
            }
        }
        if (!scope.variables.some(function (v) { return v.name === name; }) && !scopeVar)
            scope.variables.push(new CVariable(scope, name, type));
        if (varDecl.initializer)
            _this.initializer = assignment_1.AssignmentHelper.create(scope, varDecl.name, varDecl.initializer);
        return _this;
    }
    CVariableDeclaration = __decorate([
        template_1.CodeTemplate("{initializer}", ts.SyntaxKind.VariableDeclaration)
    ], CVariableDeclaration);
    return CVariableDeclaration;
}(template_1.CTemplateBase));
exports.CVariableDeclaration = CVariableDeclaration;
var CVariableAllocation = /** @class */ (function (_super) {
    __extends(CVariableAllocation, _super);
    function CVariableAllocation(scope, varName, varType, refNode) {
        var _this = _super.call(this) || this;
        _this.varName = varName;
        _this.needAllocateArray = varType instanceof ctypes_1.ArrayType && varType.isDynamicArray;
        _this.needAllocateStruct = varType instanceof ctypes_1.StructType || varType instanceof ctypes_1.FuncType && varType.needsClosureStruct;
        _this.needAllocateDict = varType instanceof ctypes_1.DictType;
        _this.initialCapacity = 4;
        _this.gcVarName = scope.root.memoryManager.getGCVariableForNode(refNode);
        if (varType instanceof ctypes_1.ArrayType) {
            _this.initialCapacity = Math.max(varType.capacity * 2, 4);
            _this.size = varType.capacity;
        }
        if (_this.needAllocateStruct || _this.needAllocateArray || _this.needAllocateDict)
            scope.root.headerFlags.malloc = true;
        if (_this.gcVarName || _this.needAllocateArray)
            scope.root.headerFlags.array = true;
        if (varType instanceof ctypes_1.ArrayType && varType.elementType == ctypes_1.UniversalVarType)
            scope.root.headerFlags.js_var_array = true;
        if (varType instanceof ctypes_1.DictType && varType.elementType == ctypes_1.UniversalVarType)
            scope.root.headerFlags.js_var_dict = true;
        else if (_this.needAllocateDict)
            scope.root.headerFlags.dict = true;
        if (_this.gcVarName)
            scope.root.headerFlags.gc_iterator = true;
        return _this;
    }
    CVariableAllocation = __decorate([
        template_1.CodeTemplate("\n{#if needAllocateArray}\n    ARRAY_CREATE({varName}, {initialCapacity}, {size});\n{#elseif needAllocateDict}\n    DICT_CREATE({varName}, {initialCapacity});\n{#elseif needAllocateStruct}\n    {varName} = malloc(sizeof(*{varName}));\n    assert({varName} != NULL);\n{/if}\n{#if gcVarName && (needAllocateStruct || needAllocateArray || needAllocateDict)}\n    ARRAY_PUSH({gcVarName}, (void *){varName});\n{/if}\n")
    ], CVariableAllocation);
    return CVariableAllocation;
}(template_1.CTemplateBase));
exports.CVariableAllocation = CVariableAllocation;
var CVariableDestructors = /** @class */ (function (_super) {
    __extends(CVariableDestructors, _super);
    function CVariableDestructors(scope, node) {
        var _this = _super.call(this) || this;
        _this.gcVarName = null;
        _this.gcArraysVarName = null;
        _this.gcArraysCVarName = null;
        _this.gcDictsVarName = null;
        _this.arrayDestructors = [];
        var gcVarNames = scope.root.memoryManager.getGCVariablesForScope(node);
        for (var _i = 0, gcVarNames_1 = gcVarNames; _i < gcVarNames_1.length; _i++) {
            var gc = gcVarNames_1[_i];
            if (gc.indexOf("_arrays_c") > -1)
                _this.gcArraysCVarName = gc;
            else if (gc.indexOf("_dicts") > -1)
                _this.gcDictsVarName = gc;
            else if (gc.indexOf("_arrays") > -1)
                _this.gcArraysVarName = gc;
            else
                _this.gcVarName = gc;
        }
        _this.destructors = [];
        scope.root.memoryManager.getDestructorsForScope(node)
            .forEach(function (r) {
            if (r.array) {
                _this.destructors.push(r.varName + "->data");
                _this.destructors.push(r.varName);
            }
            else if (r.arrayWithContents) {
                scope.root.headerFlags.gc_iterator2 = true;
                _this.arrayDestructors.push(r.varName);
                _this.destructors.push(r.varName + " ? " + r.varName + "->data : NULL");
                _this.destructors.push(r.varName);
            }
            else if (r.dict) {
                _this.destructors.push(r.varName + "->index->data");
                _this.destructors.push(r.varName + "->index");
                _this.destructors.push(r.varName + "->values->data");
                _this.destructors.push(r.varName + "->values");
                _this.destructors.push(r.varName);
            }
            else if (r.string) {
                _this.destructors.push("(char *)" + r.varName);
            }
            else
                _this.destructors.push(r.varName);
        });
        return _this;
    }
    CVariableDestructors = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {arrayDestructors => for (gc_i = 0; gc_i < ({this} ? {this}->size : 0); gc_i++) free((void*){this}->data[gc_i]);\n}\n    {destructors => free({this});\n}\n    {#if gcArraysCVarName}\n        for (gc_i = 0; gc_i < {gcArraysCVarName}->size; gc_i++) {\n            for (gc_j = 0; gc_j < ({gcArraysCVarName}->data[gc_i] ? {gcArraysCVarName}->data[gc_i]->size : 0); gc_j++)\n                free((void*){gcArraysCVarName}->data[gc_i]->data[gc_j]);\n\n            free({gcArraysCVarName}->data[gc_i] ? {gcArraysCVarName}->data[gc_i]->data : NULL);\n            free({gcArraysCVarName}->data[gc_i]);\n        }\n        free({gcArraysCVarName}->data);\n        free({gcArraysCVarName});\n    {/if}\n    {#if gcArraysVarName}\n        for (gc_i = 0; gc_i < {gcArraysVarName}->size; gc_i++) {\n            free({gcArraysVarName}->data[gc_i]->data);\n            free({gcArraysVarName}->data[gc_i]);\n        }\n        free({gcArraysVarName}->data);\n        free({gcArraysVarName});\n    {/if}\n    {#if gcDictsVarName}\n        for (gc_i = 0; gc_i < {gcDictsVarName}->size; gc_i++) {\n            free({gcDictsVarName}->data[gc_i]->index->data);\n            free({gcDictsVarName}->data[gc_i]->index);\n            free({gcDictsVarName}->data[gc_i]->values->data);\n            free({gcDictsVarName}->data[gc_i]->values);\n            free({gcDictsVarName}->data[gc_i]);\n        }\n        free({gcDictsVarName}->data);\n        free({gcDictsVarName});\n    {/if}\n    {#if gcVarName}\n        for (gc_i = 0; gc_i < {gcVarName}->size; gc_i++)\n            free({gcVarName}->data[gc_i]);\n        free({gcVarName}->data);\n        free({gcVarName});\n    {/if}\n{/statements}")
    ], CVariableDestructors);
    return CVariableDestructors;
}(template_1.CTemplateBase));
exports.CVariableDestructors = CVariableDestructors;
var CVariable = /** @class */ (function (_super) {
    __extends(CVariable, _super);
    function CVariable(scope, name, typeSource, options) {
        var _this = _super.call(this) || this;
        _this.name = name;
        var type = utils_1.isNode(typeSource) ? scope.root.typeHelper.getCType(typeSource) : typeSource;
        if (type instanceof ctypes_1.StructType)
            scope.root.symbolsHelper.ensureStruct(type, name);
        else if (type instanceof ctypes_1.ArrayType && type.isDynamicArray)
            scope.root.symbolsHelper.ensureArrayStruct(type.elementType);
        if (_this.typeHasNumber(type))
            scope.root.headerFlags.int16_t = true;
        if (type == ctypes_1.BooleanVarType)
            scope.root.headerFlags.bool = true;
        if (type instanceof ctypes_1.ArrayType && type.elementType == ctypes_1.UniversalVarType)
            scope.root.headerFlags.js_var_dict = true;
        if (type instanceof ctypes_1.DictType && type.elementType == ctypes_1.UniversalVarType)
            scope.root.headerFlags.js_var_dict = true;
        // root scope, make variables file-scoped by default
        if (scope.parent == null)
            _this.static = true;
        if (options && options.removeStorageSpecifier)
            _this.static = false;
        _this.arraysToPointers = options && options.arraysToPointers;
        if (options && options.initializer)
            _this.initializer = options.initializer;
        _this.type = type;
        _this.typeHelper = scope.root.typeHelper;
        return _this;
    }
    CVariable.prototype.typeHasNumber = function (type) {
        var _this = this;
        return type == ctypes_1.NumberVarType
            || type instanceof ctypes_1.ArrayType && this.typeHasNumber(type.elementType)
            || type instanceof ctypes_1.ArrayType && type.isDynamicArray
            || type instanceof ctypes_1.StructType && Object.keys(type.properties).some(function (k) { return _this.typeHasNumber(type.properties[k]); })
            || type instanceof ctypes_1.DictType;
    };
    CVariable.prototype.resolve = function () {
        var varString = this.typeHelper.getTypeString(this.type);
        if (this.arraysToPointers)
            varString = varString.replace(/ \{var\}\[\d+\]/g, "* {var}");
        if (varString.indexOf('{var}') > -1)
            varString = varString.replace('{var}', this.name);
        else
            varString = varString + " " + this.name;
        if (this.static && varString.indexOf('static') != 0)
            varString = 'static ' + varString;
        else if (!this.static)
            varString = varString.replace(/^static /, '');
        if (this.initializer)
            varString += " = " + this.initializer;
        return varString;
    };
    return CVariable;
}(template_1.CTemplateBase));
exports.CVariable = CVariable;
//# sourceMappingURL=variable.js.map