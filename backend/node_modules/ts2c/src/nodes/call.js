"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var standard_1 = require("../standard");
var template_1 = require("../template");
var variable_1 = require("./variable");
var ctypes_1 = require("../types/ctypes");
var typeconvert_1 = require("./typeconvert");
var utils_1 = require("../types/utils");
var literals_1 = require("./literals");
var CCallExpression = /** @class */ (function (_super) {
    __extends(CCallExpression, _super);
    function CCallExpression(scope, call) {
        var _this = _super.call(this) || this;
        _this.funcName = null;
        _this.standardCall = null;
        _this.standardCall = standard_1.StandardCallHelper.createTemplate(scope, call);
        if (_this.standardCall)
            return _this;
        // calling function that uses "this"
        var funcType = scope.root.typeHelper.getCType(call.expression);
        if (!funcType || funcType.instanceType != null) {
            _this.nodeText = call.getText();
            return _this;
        }
        _this.funcName = template_1.CodeTemplateFactory.createForNode(scope, call.expression);
        _this.arguments = call.arguments.map(function (a, i) { return funcType.parameterTypes[i] === ctypes_1.UniversalVarType ? new typeconvert_1.CAsUniversalVar(scope, a) : template_1.CodeTemplateFactory.createForNode(scope, a); });
        if (funcType.needsClosureStruct) {
            _this.arguments.push(_this.funcName);
            _this.funcName = template_1.CodeTemplateFactory.templateToString(_this.funcName) + "->func";
        }
        else {
            var _loop_1 = function (p) {
                var parentFunc = utils_1.findParentFunction(call);
                var funcType_1 = scope.root.typeHelper.getCType(parentFunc);
                var closureVarName = funcType_1 && funcType_1.needsClosureStruct && scope.root.symbolsHelper.getClosureVarName(parentFunc);
                var value = p.node.text;
                if (closureVarName && funcType_1.closureParams.some(function (p) { return p.node.text === value; }))
                    value = closureVarName + "->scope->" + value;
                this_1.arguments.push((p.assigned ? "&" : "") + value);
            };
            var this_1 = this;
            for (var _i = 0, _a = funcType.closureParams; _i < _a.length; _i++) {
                var p = _a[_i];
                _loop_1(p);
            }
        }
        return _this;
    }
    CCallExpression = __decorate([
        template_1.CodeTemplate("\n{#if standardCall}\n    {standardCall}\n{#elseif funcName}\n    {funcName}({arguments {, }=> {this}})\n{#else}\n    /* Unsupported function call: {nodeText} */\n{/if}", ts.SyntaxKind.CallExpression)
    ], CCallExpression);
    return CCallExpression;
}(template_1.CTemplateBase));
exports.CCallExpression = CCallExpression;
var CNew = /** @class */ (function (_super) {
    __extends(CNew, _super);
    function CNew(scope, node) {
        var _this = _super.call(this) || this;
        _this.funcName = "";
        _this.allocator = "";
        _this.expression = "";
        var decl = scope.root.typeHelper.getDeclaration(node.expression);
        if (decl && ts.isIdentifier(node.expression)) {
            var funcType = scope.root.typeHelper.getCType(decl);
            _this.funcName = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
            _this.arguments = node.arguments.map(function (arg) { return template_1.CodeTemplateFactory.createForNode(scope, arg); });
            var varName = scope.root.memoryManager.getReservedTemporaryVarName(node);
            if (!scope.root.memoryManager.variableWasReused(node))
                scope.variables.push(new variable_1.CVariable(scope, varName, funcType.instanceType));
            _this.arguments.unshift(varName);
            _this.allocator = new variable_1.CVariableAllocation(scope, varName, funcType.instanceType, node);
        }
        else if (ts.isIdentifier(node.expression) && node.expression.text === "Object") {
            if (node.arguments.length === 0 || utils_1.isNullOrUndefined(node.arguments[0])) {
                var objLiteral = ts.createObjectLiteral();
                objLiteral.parent = node;
                scope.root.typeHelper.registerSyntheticNode(objLiteral, ctypes_1.PointerVarType);
                _this.expression = new literals_1.CObjectLiteralExpression(scope, objLiteral);
            }
        }
        _this.nodeText = node.getText();
        return _this;
    }
    CNew = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {allocator}\n{/statements}\n{#if funcName}\n    {funcName}({arguments {, }=> {this}})\n{#elseif expression}\n    {expression}\n{#else}\n    /* Unsupported 'new' expression {nodeText} */\n{/if}", ts.SyntaxKind.NewExpression)
    ], CNew);
    return CNew;
}(template_1.CTemplateBase));
exports.CNew = CNew;
//# sourceMappingURL=call.js.map