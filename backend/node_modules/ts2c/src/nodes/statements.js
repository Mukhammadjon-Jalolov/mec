"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var template_1 = require("../template");
var ctypes_1 = require("../types/ctypes");
var variable_1 = require("./variable");
var expressions_1 = require("./expressions");
var elementaccess_1 = require("./elementaccess");
var assignment_1 = require("./assignment");
var utils_1 = require("../types/utils");
var CLabeledStatement = /** @class */ (function (_super) {
    __extends(CLabeledStatement, _super);
    function CLabeledStatement(scope, node) {
        var _this = _super.call(this) || this;
        var nodes = utils_1.getAllNodesUnder(node);
        _this.breakLabel = nodes.some(function (n) { return ts.isBreakStatement(n) && n.label.text === node.label.text; })
            ? " " + node.label.text + "_break:"
            : "";
        var hasContinue = nodes.some(function (n) { return ts.isContinueStatement(n) && n.label.text === node.label.text; });
        if (hasContinue) {
            if (ts.isForStatement(node.statement))
                _this.statement = new CForStatement(scope, node.statement, hasContinue && node.label.text + "_continue");
            else if (ts.isForOfStatement(node.statement))
                _this.statement = new CForOfStatement(scope, node.statement, hasContinue && node.label.text + "_continue");
            else if (ts.isWhileStatement(node.statement))
                _this.statement = new CWhileStatement(scope, node.statement, hasContinue && node.label.text + "_continue");
            else if (ts.isDoStatement(node.statement))
                _this.statement = new CDoWhileStatement(scope, node.statement, hasContinue && node.label.text + "_continue");
            else if (ts.isForInStatement(node.statement))
                _this.statement = new CForInStatement(scope, node.statement, hasContinue && node.label.text + "_continue");
            else
                _this.statement = "/* Unsupported labeled statement " + node.getText() + " */";
        }
        else
            _this.statement = template_1.CodeTemplateFactory.createForNode(scope, node.statement);
        return _this;
    }
    CLabeledStatement = __decorate([
        template_1.CodeTemplate("{statement}{breakLabel}", ts.SyntaxKind.LabeledStatement)
    ], CLabeledStatement);
    return CLabeledStatement;
}(template_1.CTemplateBase));
exports.CLabeledStatement = CLabeledStatement;
var CBreakStatement = /** @class */ (function (_super) {
    __extends(CBreakStatement, _super);
    function CBreakStatement(scope, node) {
        var _this = _super.call(this) || this;
        _this.label = node.label && node.label.text + "_break";
        return _this;
    }
    CBreakStatement = __decorate([
        template_1.CodeTemplate("\n{#if label}\n    goto {label};\n{#else}\n    break;\n{/if}\n", ts.SyntaxKind.BreakStatement)
    ], CBreakStatement);
    return CBreakStatement;
}(template_1.CTemplateBase));
exports.CBreakStatement = CBreakStatement;
var CContinueStatement = /** @class */ (function (_super) {
    __extends(CContinueStatement, _super);
    function CContinueStatement(scope, node) {
        var _this = _super.call(this) || this;
        _this.label = node.label && node.label.text + "_continue";
        return _this;
    }
    CContinueStatement = __decorate([
        template_1.CodeTemplate("\n{#if label}\n    goto {label};\n{#else}\n    continue;\n{/if}\n", ts.SyntaxKind.ContinueStatement)
    ], CContinueStatement);
    return CContinueStatement;
}(template_1.CTemplateBase));
exports.CContinueStatement = CContinueStatement;
var CEmptyStatement = /** @class */ (function () {
    function CEmptyStatement(scope, node) {
    }
    CEmptyStatement = __decorate([
        template_1.CodeTemplate(";\n", ts.SyntaxKind.EmptyStatement)
    ], CEmptyStatement);
    return CEmptyStatement;
}());
exports.CEmptyStatement = CEmptyStatement;
var CReturnStatement = /** @class */ (function (_super) {
    __extends(CReturnStatement, _super);
    function CReturnStatement(scope, node) {
        var _this = _super.call(this) || this;
        _this.retVarName = null;
        _this.closureParams = [];
        _this.expression = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
        _this.destructors = new variable_1.CVariableDestructors(scope, node);
        return _this;
    }
    CReturnStatement = __decorate([
        template_1.CodeTemplate("\n{destructors}\nreturn {expression};\n", ts.SyntaxKind.ReturnStatement)
    ], CReturnStatement);
    return CReturnStatement;
}(template_1.CTemplateBase));
exports.CReturnStatement = CReturnStatement;
var CIfStatement = /** @class */ (function (_super) {
    __extends(CIfStatement, _super);
    function CIfStatement(scope, node) {
        var _this = _super.call(this) || this;
        _this.condition = new expressions_1.CCondition(scope, node.expression);
        _this.thenBlock = new CBlock(scope, node.thenStatement);
        _this.hasElseBlock = !!node.elseStatement;
        _this.elseBlock = _this.hasElseBlock && new CBlock(scope, node.elseStatement);
        return _this;
    }
    CIfStatement = __decorate([
        template_1.CodeTemplate("\nif ({condition})\n{thenBlock}\n{#if hasElseBlock}\n    else\n    {elseBlock}\n{/if}\n", ts.SyntaxKind.IfStatement)
    ], CIfStatement);
    return CIfStatement;
}(template_1.CTemplateBase));
exports.CIfStatement = CIfStatement;
var CSwitchStatement = /** @class */ (function (_super) {
    __extends(CSwitchStatement, _super);
    function CSwitchStatement(scope, node) {
        var _this = _super.call(this) || this;
        var exprType = scope.root.typeHelper.getCType(node.expression);
        _this.nonIntegral = exprType != ctypes_1.NumberVarType;
        _this.expression = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
        _this.cases = node.caseBlock.clauses.map(function (clause, index) { return new CSwitchCaseClause(scope, clause, _this.nonIntegral ? index : null); });
        if (_this.nonIntegral) {
            var tempVarName = scope.root.symbolsHelper.addTemp(node, "tmp_switch");
            scope.variables.push(new variable_1.CVariable(scope, tempVarName, ctypes_1.NumberVarType));
            _this.values = node.caseBlock.clauses.filter(function (c) { return ts.isCaseClause(c); }).map(function (clause, index) { return new CSwitchCaseCompare(scope, _this.expression, clause, index); });
            _this.switch = tempVarName;
        }
        else
            _this.switch = _this.expression;
        return _this;
    }
    CSwitchStatement = __decorate([
        template_1.CodeTemplate("\n{#if nonIntegral}\n    {switch} = {values {\n        : }=> {this}}\n        : -1;\n{/if}\nswitch ({switch}) {\n    {cases {    }=> {this}\n}\n}\n", ts.SyntaxKind.SwitchStatement)
    ], CSwitchStatement);
    return CSwitchStatement;
}(template_1.CTemplateBase));
exports.CSwitchStatement = CSwitchStatement;
var CSwitchCaseClause = /** @class */ (function (_super) {
    __extends(CSwitchCaseClause, _super);
    function CSwitchCaseClause(scope, clause, index) {
        var _this = _super.call(this) || this;
        _this.variables = [];
        _this.statements = [];
        _this.parent = scope;
        _this.func = scope.func;
        _this.root = scope.root;
        _this.defaultClause = clause.kind === ts.SyntaxKind.DefaultClause;
        if (index != null)
            _this.value = "" + index;
        else if (ts.isCaseClause(clause))
            _this.value = template_1.CodeTemplateFactory.createForNode(scope, clause.expression);
        for (var _i = 0, _a = clause.statements; _i < _a.length; _i++) {
            var s = _a[_i];
            var statement = template_1.CodeTemplateFactory.createForNode(_this, s);
            _this.statements.push(statement);
        }
        return _this;
    }
    CSwitchCaseClause = __decorate([
        template_1.CodeTemplate("\n{#if !defaultClause}\n    case {value}:\n{#else}\n    default:\n{/if}\n        {statements {        }=> {this}}\n")
    ], CSwitchCaseClause);
    return CSwitchCaseClause;
}(template_1.CTemplateBase));
var CSwitchCaseCompare = /** @class */ (function (_super) {
    __extends(CSwitchCaseCompare, _super);
    function CSwitchCaseCompare(scope, expression, clause, index) {
        var _this = _super.call(this) || this;
        _this.expression = expression;
        _this.index = index;
        _this.value = template_1.CodeTemplateFactory.createForNode(scope, clause.expression);
        return _this;
    }
    CSwitchCaseCompare = __decorate([
        template_1.CodeTemplate("!strcmp({expression}, {value}) ? {index}")
    ], CSwitchCaseCompare);
    return CSwitchCaseCompare;
}(template_1.CTemplateBase));
var CWhileStatement = /** @class */ (function (_super) {
    __extends(CWhileStatement, _super);
    function CWhileStatement(scope, node, continueLabel) {
        var _this = _super.call(this) || this;
        _this.continueLabel = continueLabel;
        _this.variables = [];
        _this.statements = [];
        _this.block = new CBlock(scope, node.statement);
        _this.variables = _this.block.variables;
        _this.statements = _this.block.statements;
        _this.condition = new expressions_1.CCondition(scope, node.expression);
        return _this;
    }
    CWhileStatement = __decorate([
        template_1.CodeTemplate("\n{#if continueLabel}\n    while({condition}) {\n        {variables {    }=> {this};\n}\n        {statements {    }=> {this}}\n        {continueLabel}: ;\n    }\n{#else}\n    while ({condition})\n    {block}\n{/if}", ts.SyntaxKind.WhileStatement)
    ], CWhileStatement);
    return CWhileStatement;
}(template_1.CTemplateBase));
exports.CWhileStatement = CWhileStatement;
var CDoWhileStatement = /** @class */ (function (_super) {
    __extends(CDoWhileStatement, _super);
    function CDoWhileStatement(scope, node, continueLabel) {
        var _this = _super.call(this) || this;
        _this.continueLabel = continueLabel;
        _this.variables = [];
        _this.statements = [];
        _this.block = new CBlock(scope, node.statement);
        _this.variables = _this.block.variables;
        _this.statements = _this.block.statements;
        _this.condition = new expressions_1.CCondition(scope, node.expression);
        return _this;
    }
    CDoWhileStatement = __decorate([
        template_1.CodeTemplate("\n{#if continueLabel}\n    do {\n        {variables {    }=> {this};\n}\n        {statements {    }=> {this}}\n        {continueLabel}: ;\n    } while ({condition});\n{#else}\n    do\n    {block}\n    while ({condition});\n{/if}", ts.SyntaxKind.DoStatement)
    ], CDoWhileStatement);
    return CDoWhileStatement;
}(template_1.CTemplateBase));
exports.CDoWhileStatement = CDoWhileStatement;
var CForStatement = /** @class */ (function (_super) {
    __extends(CForStatement, _super);
    function CForStatement(scope, node, continueLabel) {
        var _this = _super.call(this) || this;
        _this.continueLabel = continueLabel;
        _this.variables = [];
        _this.statements = [];
        _this.varDecl = null;
        _this.block = new CBlock(scope, node.statement);
        _this.variables = _this.block.variables;
        _this.statements = _this.block.statements;
        if (node.initializer.kind == ts.SyntaxKind.VariableDeclarationList) {
            var declList = node.initializer;
            _this.varDecl = new variable_1.CVariableDeclaration(scope, declList.declarations[0]);
            _this.init = "";
        }
        else
            _this.init = template_1.CodeTemplateFactory.createForNode(scope, node.initializer);
        _this.condition = new expressions_1.CCondition(scope, node.condition);
        _this.increment = node.incrementor ? template_1.CodeTemplateFactory.createForNode(scope, node.incrementor) : "";
        return _this;
    }
    CForStatement = __decorate([
        template_1.CodeTemplate("\n{#if varDecl}\n    {varDecl}\n{/if}\n{#if continueLabel}\n    {init};\n    while({condition}) {\n        {variables {    }=> {this};\n}\n        {statements {    }=> {this}}\n        {continueLabel}:\n        {increment};\n    }\n{#else}\n    for ({init};{condition};{increment})\n    {block}\n{/if}", ts.SyntaxKind.ForStatement)
    ], CForStatement);
    return CForStatement;
}(template_1.CTemplateBase));
exports.CForStatement = CForStatement;
var CForOfStatement = /** @class */ (function (_super) {
    __extends(CForOfStatement, _super);
    function CForOfStatement(scope, node, continueLabel) {
        var _this = _super.call(this) || this;
        _this.continueLabel = continueLabel;
        _this.variables = [];
        _this.statements = [];
        _this.cast = "";
        _this.parent = scope;
        _this.func = scope.func;
        _this.root = scope.root;
        _this.iteratorVarName = scope.root.symbolsHelper.addIterator(node);
        scope.variables.push(new variable_1.CVariable(scope, _this.iteratorVarName, ctypes_1.NumberVarType));
        var arrType = scope.root.typeHelper.getCType(node.expression);
        var varAccess = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
        _this.elementAccess = new elementaccess_1.CSimpleElementAccess(scope, arrType, varAccess, _this.iteratorVarName);
        _this.arraySize = new elementaccess_1.CArraySize(scope, varAccess, arrType);
        if (arrType && arrType instanceof ctypes_1.ArrayType && arrType.elementType instanceof ctypes_1.ArrayType && arrType.elementType.isDynamicArray)
            _this.cast = "(void *)";
        if (node.initializer.kind == ts.SyntaxKind.VariableDeclarationList) {
            var declInit = node.initializer.declarations[0];
            scope.variables.push(new variable_1.CVariable(scope, declInit.name.getText(), declInit.name));
            _this.init = declInit.name.getText();
        }
        else
            _this.init = new elementaccess_1.CElementAccess(scope, node.initializer);
        _this.statements.push(template_1.CodeTemplateFactory.createForNode(_this, node.statement));
        scope.variables = scope.variables.concat(_this.variables);
        _this.variables = [];
        return _this;
    }
    CForOfStatement = __decorate([
        template_1.CodeTemplate("\n{#if continueLabel}\n    {iteratorVarName} = 0;\n    while ({iteratorVarName} < {arraySize}) {\n        {variables {    }=> {this};\n}\n        {init} = {cast}{elementAccess};\n    {statements {    }=> {this}}\n        {continueLabel}:\n        {iteratorVarName}++;\n    }\n{#else}\n    for ({iteratorVarName} = 0; {iteratorVarName} < {arraySize}; {iteratorVarName}++)\n    {\n        {variables {    }=> {this};\n}\n        {init} = {cast}{elementAccess};\n        {statements {    }=> {this}}\n    }\n{/if}\n", ts.SyntaxKind.ForOfStatement)
    ], CForOfStatement);
    return CForOfStatement;
}(template_1.CTemplateBase));
exports.CForOfStatement = CForOfStatement;
var CForInStatement = /** @class */ (function (_super) {
    __extends(CForInStatement, _super);
    function CForInStatement(scope, node, continueLabel) {
        var _this = _super.call(this) || this;
        _this.continueLabel = continueLabel;
        _this.variables = [];
        _this.statements = [];
        _this.parent = scope;
        _this.func = scope.func;
        _this.root = scope.root;
        _this.iteratorVarName = scope.root.symbolsHelper.addIterator(node);
        scope.variables.push(new variable_1.CVariable(scope, _this.iteratorVarName, ctypes_1.NumberVarType));
        _this.varAccess = new elementaccess_1.CElementAccess(scope, node.expression);
        if (node.initializer.kind == ts.SyntaxKind.VariableDeclarationList) {
            var declInit = node.initializer.declarations[0];
            scope.variables.push(new variable_1.CVariable(scope, declInit.name.getText(), declInit.name));
            _this.init = declInit.name.getText();
        }
        else
            _this.init = new elementaccess_1.CElementAccess(scope, node.initializer);
        if (node.statement.kind == ts.SyntaxKind.Block) {
            var block = node.statement;
            for (var _i = 0, _a = block.statements; _i < _a.length; _i++) {
                var s = _a[_i];
                _this.statements.push(template_1.CodeTemplateFactory.createForNode(_this, s));
            }
        }
        else
            _this.statements.push(template_1.CodeTemplateFactory.createForNode(_this, node.statement));
        scope.variables = scope.variables.concat(_this.variables);
        _this.variables = [];
        return _this;
    }
    CForInStatement = __decorate([
        template_1.CodeTemplate("\n{#if continueLabel}\n    {iteratorVarName} = 0;\n    while ({iteratorVarName} < {varAccess}->index->size) {\n        {variables {    }=> {this};\n}\n        {init} = {varAccess}->index->data[{iteratorVarName}];\n        {statements {    }=> {this}}\n        {continueLabel}:\n        {iteratorVarName}++;\n    }\n{#else}\n    for ({iteratorVarName} = 0; {iteratorVarName} < {varAccess}->index->size; {iteratorVarName}++)\n    {\n        {variables {    }=> {this};\n}\n        {init} = {varAccess}->index->data[{iteratorVarName}];\n        {statements {    }=> {this}}\n    }\n{/if}\n", ts.SyntaxKind.ForInStatement)
    ], CForInStatement);
    return CForInStatement;
}(template_1.CTemplateBase));
exports.CForInStatement = CForInStatement;
var CExpressionStatement = /** @class */ (function (_super) {
    __extends(CExpressionStatement, _super);
    function CExpressionStatement(scope, node) {
        var _this = _super.call(this) || this;
        _this.SemicolonCR = ';\n';
        if (node.expression.kind == ts.SyntaxKind.BinaryExpression) {
            var binExpr = node.expression;
            if (binExpr.operatorToken.kind == ts.SyntaxKind.EqualsToken) {
                _this.expression = assignment_1.AssignmentHelper.create(scope, binExpr.left, binExpr.right);
                ;
                _this.SemicolonCR = '';
            }
        }
        if (!_this.expression)
            _this.expression = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
        return _this;
    }
    CExpressionStatement = __decorate([
        template_1.CodeTemplate("{expression}{SemicolonCR}", ts.SyntaxKind.ExpressionStatement)
    ], CExpressionStatement);
    return CExpressionStatement;
}(template_1.CTemplateBase));
exports.CExpressionStatement = CExpressionStatement;
var CBlock = /** @class */ (function (_super) {
    __extends(CBlock, _super);
    function CBlock(scope, node) {
        var _this = _super.call(this) || this;
        _this.variables = [];
        _this.statements = [];
        _this.parent = scope;
        _this.func = scope.func;
        _this.root = scope.root;
        if (ts.isBlock(node)) {
            node.statements.forEach(function (s) { return _this.statements.push(template_1.CodeTemplateFactory.createForNode(_this, s)); });
        }
        else
            _this.statements.push(template_1.CodeTemplateFactory.createForNode(_this, node));
        return _this;
    }
    CBlock = __decorate([
        template_1.CodeTemplate("\n{#if statements.length > 1 || variables.length > 0}\n    {\n        {variables {    }=> {this};\n}\n        {statements {    }=> {this}}\n    }\n{/if}\n{#if statements.length == 1 && variables.length == 0}\n        {statements}\n{/if}\n{#if statements.length == 0 && variables.length == 0}\n        /* no statements */;\n{/if}", ts.SyntaxKind.Block)
    ], CBlock);
    return CBlock;
}(template_1.CTemplateBase));
exports.CBlock = CBlock;
var CImport = /** @class */ (function (_super) {
    __extends(CImport, _super);
    function CImport(scope, node) {
        var _this = _super.call(this) || this;
        var moduleName = node.moduleSpecifier.text;
        _this.externalInclude = moduleName.indexOf('ts2c-target') == 0;
        if (_this.externalInclude) {
            moduleName = moduleName.split('/').slice(1).join('/');
            if (moduleName.slice(-6) == "/index")
                moduleName = moduleName.slice(0, -6);
            if (scope.root.includes.indexOf(moduleName) == -1)
                scope.root.includes.push(moduleName);
        }
        _this.nodeText = node.getText();
        return _this;
    }
    CImport = __decorate([
        template_1.CodeTemplate("", ts.SyntaxKind.ImportDeclaration)
    ], CImport);
    return CImport;
}(template_1.CTemplateBase));
exports.CImport = CImport;
var CTryStatement = /** @class */ (function (_super) {
    __extends(CTryStatement, _super);
    function CTryStatement(scope, node) {
        var _this = _super.call(this) || this;
        _this.tryBlock = new CBlock(scope, node.tryBlock);
        _this.catchBlock = node.catchClause ? new CBlock(scope, node.catchClause.block) : "";
        _this.finallyBlock = node.finallyBlock ? new CBlock(scope, node.finallyBlock) : "";
        _this.catchVarName = node.catchClause && node.catchClause.variableDeclaration && node.catchClause.variableDeclaration.name.getText();
        if (_this.catchVarName)
            scope.variables.push(new variable_1.CVariable(scope, _this.catchVarName, ctypes_1.StringVarType));
        scope.root.headerFlags.try_catch = true;
        return _this;
    }
    CTryStatement = __decorate([
        template_1.CodeTemplate("\nTRY\n{tryBlock}\nCATCH\n{#if catchVarName}\n        {catchVarName} = err_defs->data[err_val - 1];\n{/if}\n{catchBlock}\n{finallyBlock}\nEND_TRY\n", ts.SyntaxKind.TryStatement)
    ], CTryStatement);
    return CTryStatement;
}(template_1.CTemplateBase));
exports.CTryStatement = CTryStatement;
var CThrowStatement = /** @class */ (function (_super) {
    __extends(CThrowStatement, _super);
    function CThrowStatement(scope, node) {
        var _this = _super.call(this) || this;
        _this.value = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
        scope.root.headerFlags.try_catch = true;
        return _this;
    }
    CThrowStatement = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    ARRAY_PUSH(err_defs, {value});\n{/statements}\nTHROW(err_defs->size);\n", ts.SyntaxKind.ThrowStatement)
    ], CThrowStatement);
    return CThrowStatement;
}(template_1.CTemplateBase));
exports.CThrowStatement = CThrowStatement;
//# sourceMappingURL=statements.js.map