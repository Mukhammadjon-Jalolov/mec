"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var template_1 = require("../template");
var literals_1 = require("./literals");
var regex_1 = require("../regex");
var CRegexSearchFunction = /** @class */ (function (_super) {
    __extends(CRegexSearchFunction, _super);
    function CRegexSearchFunction(scope, template, regexName, regexMachine) {
        if (regexMachine === void 0) { regexMachine = null; }
        var _this = _super.call(this) || this;
        _this.regexName = regexName;
        _this.stateBlocks = [];
        _this.groupNumber = 0;
        _this.templateString = new literals_1.CString(scope, template.replace(/\\/g, '\\\\').replace(/"/g, '\\"'));
        if (/\/[a-z]+$/.test(template))
            throw new Error("Flags not supported in regex literals yet (" + template + ").");
        regexMachine = regexMachine || regex_1.RegexBuilder.build(template.slice(1, -1));
        var max = function (arr, func) { return arr && arr.reduce(function (acc, t) { return Math.max(acc, func(t), 0); }, 0) || 0; };
        _this.groupNumber = max(regexMachine.states, function (s) { return max(s.transitions, function (t) { return max(t.startGroup, function (g) { return g; }); }); });
        _this.hasChars = regexMachine.states.filter(function (s) { return s && s.transitions.filter(function (c) { return typeof c.condition == "string" || regex_1.isRangeCondition(c.condition) || c.condition.tokens.length > 0; }); }).length > 0;
        for (var s = 0; s < regexMachine.states.length; s++) {
            if (regexMachine.states[s] == null || regexMachine.states[s].transitions.length == 0)
                continue;
            _this.stateBlocks.push(new CStateBlock(scope, s + "", regexMachine.states[s], _this.groupNumber));
        }
        _this.finals = regexMachine.states.length > 0 ? regexMachine.states.map(function (s, i) { return s.final ? i : -1; }).filter(function (f) { return f > -1; }).map(function (f) { return f + ""; }) : ["-1"];
        if (_this.groupNumber > 0)
            scope.root.headerFlags.malloc = true;
        scope.root.headerFlags.strings = true;
        scope.root.headerFlags.bool = true;
        return _this;
    }
    CRegexSearchFunction = __decorate([
        template_1.CodeTemplate("\nstruct regex_match_struct_t {regexName}_search(const char *str, int16_t capture) {\n    int16_t state = 0, next = -1, iterator, len = strlen(str), index = 0, end = -1;\n    struct regex_match_struct_t result;\n{#if hasChars}\n        char ch;\n{/if}\n{#if groupNumber}\n        int16_t started[{groupNumber}];\n        if (capture) {\n            result.matches = malloc({groupNumber} * sizeof(*result.matches));\n            assert(result.matches != NULL);\n            regex_clear_matches(&result, {groupNumber});\n            memset(started, 0, sizeof started);\n        }\n{/if}\n    for (iterator = 0; iterator < len; iterator++) {\n{#if hasChars}\n            ch = str[iterator];\n{/if}\n\n{stateBlocks}\n\n        if (next == -1) {\n            if ({finals { || }=> state == {this}})\n                break;\n            iterator = index;\n            index++;\n            state = 0;\n            end = -1;\n{#if groupNumber}\n                if (capture) {\n                    regex_clear_matches(&result, {groupNumber});\n                    memset(started, 0, sizeof started);\n                }\n{/if}\n        } else {\n            state = next;\n            next = -1;\n        }\n\n        if (iterator == len-1 && index < len-1 && {finals { && }=> state != {this}}) {\n            if (end > -1)\n                break;\n            iterator = index;\n            index++;\n            state = 0;\n{#if groupNumber}\n                if (capture) {\n                    regex_clear_matches(&result, {groupNumber});\n                    memset(started, 0, sizeof started);\n                }\n{/if}\n        }\n    }\n    if (end == -1 && {finals { && }=> state != {this}})\n        index = -1;\n    result.index = index;\n    result.end = end == -1 ? iterator : end;\n    result.matches_count = {groupNumber};\n    return result;\n}\nstruct regex_struct_t {regexName} = { {templateString}, {regexName}_search };\n")
    ], CRegexSearchFunction);
    return CRegexSearchFunction;
}(template_1.CTemplateBase));
exports.CRegexSearchFunction = CRegexSearchFunction;
var CStateBlock = /** @class */ (function (_super) {
    __extends(CStateBlock, _super);
    function CStateBlock(scope, stateNumber, state, groupNumber) {
        var _this = _super.call(this) || this;
        _this.stateNumber = stateNumber;
        _this.groupNumber = groupNumber;
        _this.conditions = [];
        _this.groupsToReset = [];
        _this.final = state.final;
        var allGroups = [];
        state.transitions.forEach(function (t) { return allGroups = allGroups.concat(t.startGroup || []).concat(t.endGroup || []); });
        for (var i = 0; i < groupNumber; i++)
            if (allGroups.indexOf(i + 1) == -1)
                _this.groupsToReset.push(i + "");
        for (var _i = 0, _a = state.transitions; _i < _a.length; _i++) {
            var tr = _a[_i];
            _this.conditions.push(new CharCondition(tr, groupNumber));
        }
        return _this;
    }
    CStateBlock = __decorate([
        template_1.CodeTemplate("\n        if (state == {stateNumber}) {\n{#if final}\n                end = iterator;\n{/if}\n{conditions {\n}=> {this}}\n{#if groupNumber && groupsToReset.length}\n                if (capture && next == -1) {\n                    {groupsToReset {\n                    }=> started[{this}] = 0;}\n                }\n{/if}\n        }\n")
    ], CStateBlock);
    return CStateBlock;
}(template_1.CTemplateBase));
var CharCondition = /** @class */ (function (_super) {
    __extends(CharCondition, _super);
    function CharCondition(tr, groupN) {
        var _this = _super.call(this) || this;
        _this.anyCharExcept = false;
        _this.anyChar = false;
        _this.charClass = false;
        _this.fixedConditions = '';
        if (tr.fixedStart)
            _this.fixedConditions = " && iterator == 0";
        else if (tr.fixedEnd)
            _this.fixedConditions = " && iterator == len - 1";
        if (typeof tr.condition === "string")
            _this.ch = tr.condition.replace('\\', '\\\\').replace("'", "\\'");
        else if (regex_1.isRangeCondition(tr.condition)) {
            _this.charClass = true;
            _this.chFrom = tr.condition.fromChar;
            _this.ch = tr.condition.toChar;
        }
        else if (tr.condition.tokens.length) {
            _this.anyCharExcept = true;
            _this.except = tr.condition.tokens.map(function (ch) { return ch.replace('\\', '\\\\').replace("'", "\\'"); });
        }
        else
            _this.anyChar = true;
        var groupCaptureCode = '';
        for (var _i = 0, _a = tr.startGroup || []; _i < _a.length; _i++) {
            var g = _a[_i];
            groupCaptureCode += " if (capture && (!started[" + (g - 1) + "] || iterator > result.matches[" + (g - 1) + "].end)) { started[" + (g - 1) + "] = 1; result.matches[" + (g - 1) + "].index = iterator; }";
        }
        for (var _b = 0, _c = tr.endGroup || []; _b < _c.length; _b++) {
            var g = _c[_b];
            groupCaptureCode += " if (capture && started[" + (g - 1) + "]) result.matches[" + (g - 1) + "].end = iterator + 1;";
        }
        _this.nextCode = "next = " + tr.next + ";";
        if (groupCaptureCode)
            _this.nextCode = "{ " + _this.nextCode + groupCaptureCode + " }";
        return _this;
    }
    CharCondition = __decorate([
        template_1.CodeTemplate("\n{#if anyCharExcept}\n                if (next == -1 && {except { && }=> ch != '{this}'}{fixedConditions}) {nextCode}\n{#elseif anyChar}\n                if (next == -1{fixedConditions}) {nextCode}\n{#elseif charClass}\n                if (ch >= '{chFrom}' && ch <= '{ch}'{fixedConditions}) {nextCode}\n{#else}\n                if (ch == '{ch}'{fixedConditions}) {nextCode}\n{/if}")
    ], CharCondition);
    return CharCondition;
}(template_1.CTemplateBase));
var CRegexAsString = /** @class */ (function (_super) {
    __extends(CRegexAsString, _super);
    function CRegexAsString(expression) {
        var _this = _super.call(this) || this;
        _this.expression = expression;
        return _this;
    }
    CRegexAsString = __decorate([
        template_1.CodeTemplate("{expression}.str")
    ], CRegexAsString);
    return CRegexAsString;
}(template_1.CTemplateBase));
exports.CRegexAsString = CRegexAsString;
//# sourceMappingURL=regexfunc.js.map