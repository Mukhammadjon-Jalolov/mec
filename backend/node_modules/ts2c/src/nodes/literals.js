"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var template_1 = require("../template");
var ctypes_1 = require("../types/ctypes");
var variable_1 = require("./variable");
var assignment_1 = require("./assignment");
var regexfunc_1 = require("./regexfunc");
var typeconvert_1 = require("./typeconvert");
var CArrayLiteralExpression = /** @class */ (function (_super) {
    __extends(CArrayLiteralExpression, _super);
    function CArrayLiteralExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.universalWrapper = false;
        var arrSize = node.elements.length;
        var type = scope.root.typeHelper.getCType(node);
        if (type === ctypes_1.UniversalVarType) {
            type = new ctypes_1.ArrayType(ctypes_1.UniversalVarType, 0, true);
            _this.universalWrapper = true;
            scope.root.headerFlags.js_var_array = true;
        }
        if (type instanceof ctypes_1.ArrayType) {
            var varName = void 0;
            var canUseInitializerList = node.elements.every(function (e) { return e.kind == ts.SyntaxKind.NumericLiteral || e.kind == ts.SyntaxKind.StringLiteral; });
            if (!type.isDynamicArray && canUseInitializerList) {
                varName = scope.root.symbolsHelper.addTemp(node, "tmp_array");
                var s = "{ ";
                for (var i_1 = 0; i_1 < arrSize; i_1++) {
                    if (i_1 != 0)
                        s += ", ";
                    var cExpr = template_1.CodeTemplateFactory.createForNode(scope, node.elements[i_1]);
                    s += typeof cExpr === 'string' ? cExpr : cExpr.resolve();
                }
                s += " }";
                scope.variables.push(new variable_1.CVariable(scope, varName, type, { initializer: s }));
            }
            else {
                if (type.isDynamicArray) {
                    varName = scope.root.memoryManager.getReservedTemporaryVarName(node);
                    if (!scope.root.memoryManager.variableWasReused(node))
                        scope.func.variables.push(new variable_1.CVariable(scope, varName, type, { initializer: "NULL" }));
                    scope.root.headerFlags.array = true;
                    scope.statements.push("ARRAY_CREATE(" + varName + ", " + Math.max(arrSize, 2) + ", " + arrSize + ");\n");
                    var gcVarName = scope.root.memoryManager.getGCVariableForNode(node);
                    if (gcVarName) {
                        scope.statements.push("ARRAY_PUSH(" + gcVarName + ", (void *)" + varName + ");\n");
                        scope.root.headerFlags.gc_iterator = true;
                        scope.root.headerFlags.array = true;
                    }
                }
                else {
                    varName = scope.root.symbolsHelper.addTemp(node, "tmp_array");
                    scope.variables.push(new variable_1.CVariable(scope, varName, type));
                }
                for (var i_2 = 0; i_2 < arrSize; i_2++) {
                    var assignment = new assignment_1.CAssignment(scope, varName, i_2 + "", type, node.elements[i_2]);
                    scope.statements.push(assignment);
                }
            }
            _this.expression = varName;
        }
        else
            _this.expression = "/* Unsupported use of array literal expression */";
        return _this;
    }
    CArrayLiteralExpression = __decorate([
        template_1.CodeTemplate("\n{#if universalWrapper}\n    js_var_from_array({expression})\n{#else}\n    {expression}\n{/if}", ts.SyntaxKind.ArrayLiteralExpression)
    ], CArrayLiteralExpression);
    return CArrayLiteralExpression;
}(template_1.CTemplateBase));
var CObjectLiteralExpression = /** @class */ (function (_super) {
    __extends(CObjectLiteralExpression, _super);
    function CObjectLiteralExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.expression = '';
        _this.universalWrapper = false;
        var type = scope.root.typeHelper.getCType(node);
        if (type === ctypes_1.UniversalVarType) {
            type = new ctypes_1.DictType(ctypes_1.UniversalVarType);
            _this.universalWrapper = true;
            scope.root.headerFlags.js_var_dict = true;
        }
        _this.isStruct = type instanceof ctypes_1.StructType;
        _this.isDict = type instanceof ctypes_1.DictType;
        if (_this.isStruct || _this.isDict) {
            var varName_1 = scope.root.memoryManager.getReservedTemporaryVarName(node);
            if (!scope.root.memoryManager.variableWasReused(node))
                scope.func.variables.push(new variable_1.CVariable(scope, varName_1, type, { initializer: "NULL" }));
            _this.allocator = new variable_1.CVariableAllocation(scope, varName_1, type, node);
            _this.initializers = node.properties
                .filter(function (p) { return p.kind == ts.SyntaxKind.PropertyAssignment; })
                .map(function (p) { return p; })
                .map(function (p) {
                var propName = (ts.isIdentifier(p.name) || ts.isStringLiteral(p.name)) && p.name.text;
                return new assignment_1.CAssignment(scope, varName_1, _this.isDict ? '"' + propName + '"' : propName, type, p.initializer);
            });
            _this.expression = varName_1;
        }
        else
            _this.expression = "/* Unsupported use of object literal expression */";
        return _this;
    }
    CObjectLiteralExpression = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {#if isStruct || isDict}\n        {allocator}\n        {initializers}\n    {/if}\n{/statements}\n{#if universalWrapper}\n    js_var_from_dict({expression})\n{#else}\n    {expression}\n{/if}", ts.SyntaxKind.ObjectLiteralExpression)
    ], CObjectLiteralExpression);
    return CObjectLiteralExpression;
}(template_1.CTemplateBase));
exports.CObjectLiteralExpression = CObjectLiteralExpression;
var regexNames = {};
var CRegexLiteralExpression = /** @class */ (function (_super) {
    __extends(CRegexLiteralExpression, _super);
    function CRegexLiteralExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.expression = '';
        var template = node.text;
        if (!regexNames[template]) {
            regexNames[template] = scope.root.symbolsHelper.addTemp(null, "regex");
            scope.root.functions.splice(scope.parent ? -2 : -1, 0, new regexfunc_1.CRegexSearchFunction(scope, template, regexNames[template]));
        }
        _this.expression = regexNames[template];
        scope.root.headerFlags.regex = true;
        return _this;
    }
    CRegexLiteralExpression = __decorate([
        template_1.CodeTemplate("{expression}", ts.SyntaxKind.RegularExpressionLiteral)
    ], CRegexLiteralExpression);
    return CRegexLiteralExpression;
}(template_1.CTemplateBase));
var CString = /** @class */ (function (_super) {
    __extends(CString, _super);
    function CString(scope, nodeOrString) {
        var _this = _super.call(this) || this;
        _this.universalWrapper = false;
        var s = typeof nodeOrString === 'string' ? '"' + nodeOrString + '"' : nodeOrString.getText();
        s = s.replace(/\\u([A-Fa-f0-9]{4})/g, function (match, g1) { return String.fromCharCode(parseInt(g1, 16)); });
        if (s.indexOf("'") == 0)
            _this.value = '"' + s.replace(/"/g, '\\"').replace(/([^\\])\\'/g, "$1'").slice(1, -1) + '"';
        else
            _this.value = s;
        if (typeof (nodeOrString) !== "string" && scope.root.typeHelper.getCType(nodeOrString) == ctypes_1.UniversalVarType)
            _this.value = new typeconvert_1.CAsUniversalVar(scope, _this.value, ctypes_1.StringVarType);
        return _this;
    }
    CString = __decorate([
        template_1.CodeTemplate("{value}", ts.SyntaxKind.StringLiteral)
    ], CString);
    return CString;
}(template_1.CTemplateBase));
exports.CString = CString;
var CNumber = /** @class */ (function () {
    function CNumber(scope, node) {
        this.universalWrapper = false;
        this.value = node.getText();
        if (scope.root.typeHelper.getCType(node) == ctypes_1.UniversalVarType)
            this.value = new typeconvert_1.CAsUniversalVar(scope, this.value, ctypes_1.NumberVarType);
    }
    CNumber = __decorate([
        template_1.CodeTemplate("{value}", ts.SyntaxKind.NumericLiteral)
    ], CNumber);
    return CNumber;
}());
exports.CNumber = CNumber;
var CBoolean = /** @class */ (function (_super) {
    __extends(CBoolean, _super);
    function CBoolean(scope, node) {
        var _this = _super.call(this) || this;
        _this.value = node.kind == ts.SyntaxKind.TrueKeyword ? "TRUE" : "FALSE";
        scope.root.headerFlags.bool = true;
        if (scope.root.typeHelper.getCType(node) == ctypes_1.UniversalVarType)
            _this.value = new typeconvert_1.CAsUniversalVar(scope, _this.value, ctypes_1.BooleanVarType);
        return _this;
    }
    CBoolean = __decorate([
        template_1.CodeTemplate("{value}", [ts.SyntaxKind.TrueKeyword, ts.SyntaxKind.FalseKeyword])
    ], CBoolean);
    return CBoolean;
}(template_1.CTemplateBase));
exports.CBoolean = CBoolean;
var CNull = /** @class */ (function (_super) {
    __extends(CNull, _super);
    function CNull(scope) {
        var _this = _super.call(this) || this;
        scope.root.headerFlags.js_var_from = true;
        return _this;
    }
    CNull = __decorate([
        template_1.CodeTemplate("js_var_from(JS_VAR_NULL)", ts.SyntaxKind.NullKeyword)
    ], CNull);
    return CNull;
}(template_1.CTemplateBase));
exports.CNull = CNull;
var CUndefined = /** @class */ (function (_super) {
    __extends(CUndefined, _super);
    function CUndefined(scope) {
        var _this = _super.call(this) || this;
        scope.root.headerFlags.js_var_from = true;
        return _this;
    }
    CUndefined = __decorate([
        template_1.CodeTemplate("js_var_from(JS_VAR_UNDEFINED)", ts.SyntaxKind.UndefinedKeyword)
    ], CUndefined);
    return CUndefined;
}(template_1.CTemplateBase));
exports.CUndefined = CUndefined;
var CNaN = /** @class */ (function (_super) {
    __extends(CNaN, _super);
    function CNaN(scope, node) {
        var _this = _super.call(this) || this;
        scope.root.headerFlags.js_var_from = true;
        return _this;
    }
    CNaN = __decorate([
        template_1.CodeTemplate("js_var_from(JS_VAR_NAN)", ts.SyntaxKind.Count + 1)
    ], CNaN);
    return CNaN;
}(template_1.CTemplateBase));
exports.CNaN = CNaN;
var CThis = /** @class */ (function (_super) {
    __extends(CThis, _super);
    function CThis(scope, node) {
        return _super.call(this) || this;
    }
    CThis = __decorate([
        template_1.CodeTemplate("this", ts.SyntaxKind.ThisKeyword)
    ], CThis);
    return CThis;
}(template_1.CTemplateBase));
exports.CThis = CThis;
//# sourceMappingURL=literals.js.map