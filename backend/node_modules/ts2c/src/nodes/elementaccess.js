"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var template_1 = require("../template");
var ctypes_1 = require("../types/ctypes");
var literals_1 = require("./literals");
var typeconvert_1 = require("./typeconvert");
var utils_1 = require("../types/utils");
var CElementAccess = /** @class */ (function (_super) {
    __extends(CElementAccess, _super);
    function CElementAccess(scope, node) {
        var _this = _super.call(this) || this;
        var type = null;
        var elementAccess = null;
        var argumentExpression = null;
        var isScopeVariable = false;
        if (ts.isIdentifier(node)) {
            type = scope.root.typeHelper.getCType(node);
            isScopeVariable = scope.root.typeHelper.isScopeVariable(node);
            elementAccess = node.text;
            if (utils_1.isInBoolContext(node) && type instanceof ctypes_1.ArrayType && !type.isDynamicArray) {
                argumentExpression = "0";
            }
            else if (type instanceof ctypes_1.FuncType && type.needsClosureStruct) {
                var decl = scope.root.typeHelper.getDeclaration(node);
                elementAccess = scope.root.memoryManager.getReservedTemporaryVarName(decl) || elementAccess;
            }
        }
        else if (node.kind == ts.SyntaxKind.PropertyAccessExpression) {
            var propAccess = node;
            type = scope.root.typeHelper.getCType(propAccess.expression);
            if (ts.isIdentifier(propAccess.expression)) {
                elementAccess = propAccess.expression.text;
                isScopeVariable = scope.root.typeHelper.isScopeVariable(propAccess.expression);
            }
            else
                elementAccess = new CElementAccess_1(scope, propAccess.expression);
            if (type === ctypes_1.UniversalVarType) {
                argumentExpression = 'js_var_from_str("' + propAccess.name.text + '")';
                scope.root.headerFlags.js_var_from_str = true;
            }
            else if (type instanceof ctypes_1.DictType)
                argumentExpression = '"' + propAccess.name.text + '"';
            else
                argumentExpression = propAccess.name.text;
        }
        else if (node.kind == ts.SyntaxKind.ElementAccessExpression) {
            var elemAccess = node;
            type = scope.root.typeHelper.getCType(elemAccess.expression);
            if (ts.isIdentifier(elemAccess.expression)) {
                elementAccess = elemAccess.expression.text;
                isScopeVariable = scope.root.typeHelper.isScopeVariable(elemAccess.expression);
            }
            else
                elementAccess = new CElementAccess_1(scope, elemAccess.expression);
            if (type === ctypes_1.UniversalVarType)
                argumentExpression = new typeconvert_1.CAsUniversalVar(scope, elemAccess.argumentExpression);
            else if (type instanceof ctypes_1.StructType && elemAccess.argumentExpression.kind == ts.SyntaxKind.StringLiteral) {
                var ident = elemAccess.argumentExpression.getText().slice(1, -1);
                if (ident.search(/^[_A-Za-z][_A-Za-z0-9]*$/) > -1)
                    argumentExpression = ident;
                else
                    argumentExpression = template_1.CodeTemplateFactory.createForNode(scope, elemAccess.argumentExpression);
            }
            else
                argumentExpression = template_1.CodeTemplateFactory.createForNode(scope, elemAccess.argumentExpression);
        }
        else {
            type = scope.root.typeHelper.getCType(node);
            elementAccess = template_1.CodeTemplateFactory.createForNode(scope, node);
        }
        var parentFunc = utils_1.findParentFunction(node);
        var parentFuncType = scope.root.typeHelper.getCType(parentFunc);
        if (parentFuncType && parentFuncType.needsClosureStruct && parentFuncType.closureParams.some(function (p) { return p.refs.some(function (r) { return r.pos === node.pos; }); }))
            elementAccess = scope.root.symbolsHelper.getClosureVarName(parentFunc) + "->scope->" + template_1.CodeTemplateFactory.templateToString(elementAccess);
        else if (parentFuncType && parentFuncType.closureParams.some(function (p) { return p.refs.some(function (r) { return r.pos === node.pos; }) && p.assigned; }))
            elementAccess = "*" + template_1.CodeTemplateFactory.templateToString(elementAccess);
        else if (isScopeVariable)
            elementAccess = scope.root.symbolsHelper.getScopeVarName(parentFunc) + "->" + template_1.CodeTemplateFactory.templateToString(elementAccess);
        _this.simpleAccessor = new CSimpleElementAccess(scope, type, elementAccess, argumentExpression);
        return _this;
    }
    CElementAccess_1 = CElementAccess;
    CElementAccess = CElementAccess_1 = __decorate([
        template_1.CodeTemplate("{simpleAccessor}", [ts.SyntaxKind.ElementAccessExpression, ts.SyntaxKind.PropertyAccessExpression, ts.SyntaxKind.Identifier])
    ], CElementAccess);
    return CElementAccess;
    var CElementAccess_1;
}(template_1.CTemplateBase));
exports.CElementAccess = CElementAccess;
var CSimpleElementAccess = /** @class */ (function (_super) {
    __extends(CSimpleElementAccess, _super);
    function CSimpleElementAccess(scope, type, elementAccess, argumentExpression) {
        var _this = _super.call(this) || this;
        _this.elementAccess = elementAccess;
        _this.argumentExpression = argumentExpression;
        _this.isDynamicArray = false;
        _this.isStaticArray = false;
        _this.isStruct = false;
        _this.isDict = false;
        _this.isString = false;
        _this.nullValue = "0";
        _this.isUniversalAccess = false;
        _this.isSimpleVar = typeof type === 'string' && type != ctypes_1.UniversalVarType && type != ctypes_1.PointerVarType;
        _this.isDynamicArray = type instanceof ctypes_1.ArrayType && type.isDynamicArray;
        _this.isStaticArray = type instanceof ctypes_1.ArrayType && !type.isDynamicArray;
        _this.arrayCapacity = type instanceof ctypes_1.ArrayType && !type.isDynamicArray && type.capacity + "";
        _this.isDict = type instanceof ctypes_1.DictType;
        _this.isStruct = type instanceof ctypes_1.StructType;
        if (type === ctypes_1.UniversalVarType && argumentExpression != null) {
            _this.isUniversalAccess = true;
            scope.root.headerFlags.js_var_get = true;
        }
        _this.isString = type === ctypes_1.StringVarType;
        if (argumentExpression != null && type instanceof ctypes_1.DictType && type.elementType === ctypes_1.UniversalVarType)
            _this.nullValue = new literals_1.CUndefined(scope);
        if (_this.isString && _this.argumentExpression == "length")
            scope.root.headerFlags.str_len = true;
        return _this;
    }
    CSimpleElementAccess = __decorate([
        template_1.CodeTemplate("\n{#if isString && argumentExpression == 'length'}\n    str_len({elementAccess})\n{#elseif isSimpleVar || argumentExpression == null}\n    {elementAccess}\n{#elseif isDynamicArray && argumentExpression == 'length'}\n    {elementAccess}->size\n{#elseif isDynamicArray}\n    {elementAccess}->data[{argumentExpression}]\n{#elseif isStaticArray && argumentExpression == 'length'}\n    {arrayCapacity}\n{#elseif isStaticArray}\n    {elementAccess}[{argumentExpression}]\n{#elseif isStruct}\n    {elementAccess}->{argumentExpression}\n{#elseif isDict}\n    DICT_GET({elementAccess}, {argumentExpression}, {nullValue})\n{#elseif isUniversalAccess}\n    js_var_get({elementAccess}, {argumentExpression})\n{#else}\n    /* Unsupported element access scenario: {elementAccess} {argumentExpression} */\n{/if}")
    ], CSimpleElementAccess);
    return CSimpleElementAccess;
}(template_1.CTemplateBase));
exports.CSimpleElementAccess = CSimpleElementAccess;
var CArraySize = /** @class */ (function (_super) {
    __extends(CArraySize, _super);
    function CArraySize(scope, varAccess, type) {
        var _this = _super.call(this) || this;
        _this.varAccess = varAccess;
        _this.type = type;
        _this.arrayCapacity = type.capacity + "";
        return _this;
    }
    CArraySize = __decorate([
        template_1.CodeTemplate("\n{#if type.isDynamicArray}\n    {varAccess}->size\n{#else}\n    {arrayCapacity}\n{/if}")
    ], CArraySize);
    return CArraySize;
}(template_1.CTemplateBase));
exports.CArraySize = CArraySize;
//# sourceMappingURL=elementaccess.js.map