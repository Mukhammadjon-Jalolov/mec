"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var template_1 = require("../template");
var ctypes_1 = require("../types/ctypes");
var elementaccess_1 = require("./elementaccess");
var typeconvert_1 = require("./typeconvert");
var AssignmentHelper = /** @class */ (function () {
    function AssignmentHelper() {
    }
    AssignmentHelper.create = function (scope, left, right, inline) {
        if (inline === void 0) { inline = false; }
        var accessor;
        var varType;
        var argumentExpression;
        if (left.kind === ts.SyntaxKind.ElementAccessExpression) {
            var elemAccess = left;
            varType = scope.root.typeHelper.getCType(elemAccess.expression);
            if (elemAccess.expression.kind == ts.SyntaxKind.Identifier)
                accessor = elemAccess.expression.getText();
            else
                accessor = new elementaccess_1.CElementAccess(scope, elemAccess.expression);
            if (varType instanceof ctypes_1.StructType && elemAccess.argumentExpression.kind == ts.SyntaxKind.StringLiteral) {
                var ident = elemAccess.argumentExpression.getText().slice(1, -1);
                if (ident.search(/^[_A-Za-z][_A-Za-z0-9]*$/) > -1)
                    argumentExpression = ident;
                else
                    argumentExpression = template_1.CodeTemplateFactory.createForNode(scope, elemAccess.argumentExpression);
            }
            else
                argumentExpression = template_1.CodeTemplateFactory.createForNode(scope, elemAccess.argumentExpression);
        }
        else {
            varType = scope.root.typeHelper.getCType(left);
            accessor = new elementaccess_1.CElementAccess(scope, left);
            argumentExpression = null;
        }
        return new CAssignment(scope, accessor, argumentExpression, varType, right, inline);
    };
    return AssignmentHelper;
}());
exports.AssignmentHelper = AssignmentHelper;
var CAssignment = /** @class */ (function (_super) {
    __extends(CAssignment, _super);
    function CAssignment(scope, accessor, argumentExpression, type, right, inline) {
        if (inline === void 0) { inline = false; }
        var _this = _super.call(this) || this;
        _this.accessor = accessor;
        _this.argumentExpression = argumentExpression;
        _this.isObjLiteralAssignment = false;
        _this.isArrayLiteralAssignment = false;
        _this.isDynamicArray = false;
        _this.isStaticArray = false;
        _this.isStruct = false;
        _this.isDict = false;
        _this.isNewExpression = false;
        _this.isUniversalVar = false;
        _this.assignmentRemoved = false;
        _this.CR = inline ? "" : ";\n";
        _this.isNewExpression = right.kind === ts.SyntaxKind.NewExpression;
        _this.isDynamicArray = type instanceof ctypes_1.ArrayType && type.isDynamicArray;
        _this.isStaticArray = type instanceof ctypes_1.ArrayType && !type.isDynamicArray;
        _this.isDict = type instanceof ctypes_1.DictType;
        _this.isStruct = type instanceof ctypes_1.StructType;
        _this.isUniversalVar = type === ctypes_1.UniversalVarType;
        _this.nodeText = right.pos < 0 ? "(synthetized node)" : right.getText();
        var argType = type;
        var argAccessor = accessor;
        if (argumentExpression) {
            if (type instanceof ctypes_1.StructType && typeof argumentExpression === 'string')
                argType = type.properties[argumentExpression];
            else if (type instanceof ctypes_1.ArrayType || type instanceof ctypes_1.DictType)
                argType = type.elementType;
            argAccessor = new elementaccess_1.CSimpleElementAccess(scope, type, accessor, argumentExpression);
        }
        var isTempVar = !!scope.root.memoryManager.getReservedTemporaryVarName(right);
        if (right.kind == ts.SyntaxKind.ObjectLiteralExpression && !isTempVar) {
            _this.isObjLiteralAssignment = true;
            var objLiteral = right;
            _this.objInitializers = objLiteral.properties
                .filter(function (p) { return p.kind == ts.SyntaxKind.PropertyAssignment; })
                .map(function (p) { return p; })
                .map(function (p) {
                var propName = (ts.isIdentifier(p.name) || ts.isStringLiteral(p.name)) && p.name.text;
                return new CAssignment_1(scope, argAccessor, _this.isDict ? '"' + propName + '"' : propName, argType, p.initializer);
            });
        }
        else if (right.kind == ts.SyntaxKind.ArrayLiteralExpression && !isTempVar) {
            _this.isArrayLiteralAssignment = true;
            var arrLiteral = right;
            _this.arrayLiteralSize = arrLiteral.elements.length;
            _this.arrInitializers = arrLiteral.elements.map(function (e, i) { return new CAssignment_1(scope, argAccessor, "" + i, argType, e); });
        }
        else if (!_this.isUniversalVar && argType == ctypes_1.UniversalVarType) {
            _this.expression = new typeconvert_1.CAsUniversalVar(scope, right);
        }
        else
            _this.expression = template_1.CodeTemplateFactory.createForNode(scope, right);
        if (_this.argumentExpression == null) {
            var expr = typeof _this.expression == "string" ? _this.expression : _this.expression && _this.expression["resolve"] && _this.expression["resolve"]();
            var acc = typeof _this.accessor == "string" ? _this.accessor : _this.accessor && _this.accessor["resolve"] && _this.accessor["resolve"]();
            if (expr == '' || acc == expr || "((void *)" + acc + ")" == expr)
                _this.assignmentRemoved = true;
        }
        return _this;
    }
    CAssignment_1 = CAssignment;
    CAssignment = CAssignment_1 = __decorate([
        template_1.CodeTemplate("\n{#if assignmentRemoved}\n{#elseif isNewExpression}\n    {expression}{CR}\n{#elseif isObjLiteralAssignment}\n    {objInitializers}\n{#elseif isArrayLiteralAssignment}\n    {arrInitializers}\n{#elseif isDynamicArray && argumentExpression == null}\n    {accessor} = ((void *){expression}){CR}\n{#elseif argumentExpression == null}\n    {accessor} = {expression}{CR}\n{#elseif isStruct}\n    {accessor}->{argumentExpression} = {expression}{CR}\n{#elseif isDict}\n    DICT_SET({accessor}, {argumentExpression}, {expression}){CR}\n{#elseif isDynamicArray}\n    {accessor}->data[{argumentExpression}] = {expression}{CR}\n{#elseif isStaticArray}\n    {accessor}[{argumentExpression}] = {expression}{CR}\n{#elseif isUniversalVar}\n    if ({accessor}.type == JS_VAR_DICT)\n        DICT_SET(((struct dict_js_var_t *){accessor}.data), {argumentExpression}, {expression})\n{#else}\n    /* Unsupported assignment {accessor}[{argumentExpression}] = {nodeText} */{CR}\n{/if}")
    ], CAssignment);
    return CAssignment;
    var CAssignment_1;
}(template_1.CTemplateBase));
exports.CAssignment = CAssignment;
//# sourceMappingURL=assignment.js.map