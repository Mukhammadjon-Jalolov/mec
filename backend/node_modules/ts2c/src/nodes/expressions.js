"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var assignment_1 = require("./assignment");
var template_1 = require("../template");
var ctypes_1 = require("../types/ctypes");
var variable_1 = require("./variable");
var regexfunc_1 = require("./regexfunc");
var literals_1 = require("./literals");
var typeconvert_1 = require("./typeconvert");
var utils_1 = require("../types/utils");
var elementaccess_1 = require("./elementaccess");
var standard_1 = require("../standard");
var CCondition = /** @class */ (function (_super) {
    __extends(CCondition, _super);
    function CCondition(scope, node) {
        var _this = _super.call(this) || this;
        _this.universalWrapper = false;
        _this.isString = false;
        _this.expressionIsIdentifier = false;
        _this.expression = template_1.CodeTemplateFactory.createForNode(scope, node);
        _this.expressionIsIdentifier = ts.isIdentifier(node);
        var type = scope.root.typeHelper.getCType(node);
        _this.isString = type == ctypes_1.StringVarType;
        if (type == ctypes_1.UniversalVarType) {
            _this.universalWrapper = true;
            scope.root.headerFlags.js_var_to_bool = true;
        }
        return _this;
    }
    CCondition = __decorate([
        template_1.CodeTemplate("\n{#if universalWrapper}\n    js_var_to_bool({expression})\n{#elseif isString && expressionIsIdentifier}\n    *{expression}\n{#elseif isString}\n    *({expression})\n{#else}\n    {expression}\n{/if}")
    ], CCondition);
    return CCondition;
}(template_1.CTemplateBase));
exports.CCondition = CCondition;
var CBinaryExpression = /** @class */ (function (_super) {
    __extends(CBinaryExpression, _super);
    function CBinaryExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.expression = null;
        if (node.operatorToken.kind == ts.SyntaxKind.EqualsToken) {
            _this.expression = assignment_1.AssignmentHelper.create(scope, node.left, node.right, true);
            return _this;
        }
        if (node.operatorToken.kind == ts.SyntaxKind.CommaToken) {
            var nodeAsStatement = ts.createNode(ts.SyntaxKind.ExpressionStatement);
            nodeAsStatement.expression = node.left;
            nodeAsStatement.parent = node.getSourceFile();
            scope.statements.push(template_1.CodeTemplateFactory.createForNode(scope, nodeAsStatement));
            _this.expression = template_1.CodeTemplateFactory.createForNode(scope, node.right);
            return _this;
        }
        if (node.operatorToken.kind == ts.SyntaxKind.PlusToken) {
            _this.expression = new CPlusExpression(scope, node);
            return _this;
        }
        if (node.operatorToken.kind == ts.SyntaxKind.PlusEqualsToken) {
            var left = template_1.CodeTemplateFactory.createForNode(scope, node.left);
            var right = new CPlusExpression(scope, node);
            _this.expression = "(" + template_1.CodeTemplateFactory.templateToString(left) + " = " + template_1.CodeTemplateFactory.templateToString(right) + ")";
        }
        if (utils_1.isNumberOp(node.operatorToken.kind) || utils_1.isIntegerOp(node.operatorToken.kind)) {
            _this.expression = new CArithmeticExpression(scope, node);
            return _this;
        }
        if (utils_1.isRelationalOp(node.operatorToken.kind)) {
            _this.expression = new CRelationalExpression(scope, node);
            return _this;
        }
        if (utils_1.isEqualityOp(node.operatorToken.kind)) {
            _this.expression = new CEqualityExpression(scope, node);
            return _this;
        }
        if (node.operatorToken.kind === ts.SyntaxKind.InKeyword) {
            _this.expression = new CInExpression(scope, node);
            return _this;
        }
        if (utils_1.isLogicOp(node.operatorToken.kind)) {
            _this.expression = new CLogicExpession(scope, node);
            return _this;
        }
        _this.nodeText = node.flags & ts.NodeFlags.Synthesized ? "(synthesized node)" : node.getText();
        return _this;
    }
    CBinaryExpression = __decorate([
        template_1.CodeTemplate("\n{#if expression}\n    {expression}\n{#else}\n    /* unsupported expression {nodeText} */\n{/if}", ts.SyntaxKind.BinaryExpression)
    ], CBinaryExpression);
    return CBinaryExpression;
}(template_1.CTemplateBase));
exports.CBinaryExpression = CBinaryExpression;
var CLogicExpession = /** @class */ (function (_super) {
    __extends(CLogicExpession, _super);
    function CLogicExpession(scope, node) {
        var _this = _super.call(this) || this;
        _this.leftVarName = "";
        _this.rightVarName = "";
        var type = scope.root.typeHelper.getCType(node);
        if (type === ctypes_1.UniversalVarType) {
            _this.left = new typeconvert_1.CAsUniversalVar(scope, node.left);
            _this.right = new typeconvert_1.CAsUniversalVar(scope, node.right);
        }
        else {
            _this.left = template_1.CodeTemplateFactory.createForNode(scope, node.left);
            _this.right = template_1.CodeTemplateFactory.createForNode(scope, node.right);
        }
        _this.isBoolContext = utils_1.isInBoolContext(node) && type !== ctypes_1.UniversalVarType;
        var isOr = node.operatorToken.kind === ts.SyntaxKind.BarBarToken;
        if (_this.isBoolContext) {
            _this.operator = isOr ? "||" : "&&";
        }
        else {
            if (!utils_1.isSimpleNode(node.left)) {
                _this.leftVarName = scope.root.symbolsHelper.addTemp(node, "tmp1");
                scope.variables.push(new variable_1.CVariable(scope, _this.leftVarName, type));
            }
            if (!utils_1.isSimpleNode(node.right)) {
                _this.rightVarName = scope.root.symbolsHelper.addTemp(node, "tmp2");
                scope.variables.push(new variable_1.CVariable(scope, _this.rightVarName, type));
            }
            if (_this.leftVarName && type === ctypes_1.UniversalVarType) {
                _this.condition = "js_var_to_bool(" + _this.leftVarName + ")";
                scope.root.headerFlags.js_var_to_bool = true;
            }
            else
                _this.condition = _this.leftVarName || new CCondition(scope, node.left);
            if (isOr) {
                _this.whenTrue = _this.leftVarName || _this.left;
                _this.whenFalse = _this.rightVarName || _this.right;
            }
            else {
                _this.whenTrue = _this.rightVarName || _this.right;
                _this.whenFalse = _this.leftVarName || _this.left;
            }
        }
        return _this;
    }
    CLogicExpession = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {#if leftVarName}\n        {leftVarName} = {left};\n    {/if}\n    {#if rightVarName}\n        {rightVarName} = {right};\n    {/if}\n{/statements}\n{#if isBoolContext}\n    {left} {operator} {right}\n{#else}\n    {condition} ? {whenTrue} : {whenFalse}\n{/if}")
    ], CLogicExpession);
    return CLogicExpession;
}(template_1.CTemplateBase));
var CArithmeticExpression = /** @class */ (function (_super) {
    __extends(CArithmeticExpression, _super);
    function CArithmeticExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.operator = null;
        _this.computeOperation = null;
        var leftType = scope.root.typeHelper.getCType(node.left);
        var rightType = scope.root.typeHelper.getCType(node.right);
        _this.isCompoundAssignment = utils_1.isCompoundAssignment(node.operatorToken);
        if (utils_1.toNumberCanBeNaN(leftType) || utils_1.toNumberCanBeNaN(rightType)) {
            var js_var_operator_map = (_a = {},
                _a[ts.SyntaxKind.AsteriskToken] = "JS_VAR_ASTERISK",
                _a[ts.SyntaxKind.AsteriskEqualsToken] = "JS_VAR_ASTERISK",
                _a[ts.SyntaxKind.SlashToken] = "JS_VAR_SLASH",
                _a[ts.SyntaxKind.SlashEqualsToken] = "JS_VAR_SLASH",
                _a[ts.SyntaxKind.PercentToken] = "JS_VAR_PERCENT",
                _a[ts.SyntaxKind.PercentEqualsToken] = "JS_VAR_PERCENT",
                _a[ts.SyntaxKind.MinusToken] = "JS_VAR_MINUS",
                _a[ts.SyntaxKind.MinusEqualsToken] = "JS_VAR_MINUS",
                _a[ts.SyntaxKind.LessThanLessThanToken] = "JS_VAR_SHL",
                _a[ts.SyntaxKind.LessThanLessThanEqualsToken] = "JS_VAR_SHL",
                _a[ts.SyntaxKind.GreaterThanGreaterThanToken] = "JS_VAR_SHR",
                _a[ts.SyntaxKind.GreaterThanGreaterThanEqualsToken] = "JS_VAR_SHR",
                _a[ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken] = "JS_VAR_USHR",
                _a[ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken] = "JS_VAR_USHR",
                _a[ts.SyntaxKind.BarToken] = "JS_VAR_OR",
                _a[ts.SyntaxKind.BarEqualsToken] = "JS_VAR_OR",
                _a[ts.SyntaxKind.AmpersandToken] = "JS_VAR_AND",
                _a[ts.SyntaxKind.AmpersandEqualsToken] = "JS_VAR_AND",
                _a);
            _this.computeOperation = js_var_operator_map[node.operatorToken.kind];
            _this.left = new typeconvert_1.CAsUniversalVar(scope, node.left);
            _this.right = new typeconvert_1.CAsUniversalVar(scope, node.right);
            scope.root.headerFlags.js_var_compute = true;
        }
        else {
            _this.operator = node.operatorToken.getText();
            _this.left = new typeconvert_1.CAsNumber(scope, node.left);
            _this.right = new typeconvert_1.CAsNumber(scope, node.right);
            if (node.operatorToken.kind == ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken
                || node.operatorToken.kind == ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken) {
                _this.operator = ">>";
                var leftAsString = template_1.CodeTemplateFactory.templateToString(_this.left);
                _this.left = "((uint16_t)" + leftAsString + ")";
                if (node.operatorToken.kind == ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken)
                    _this.left = leftAsString + " = " + _this.left;
                scope.root.headerFlags.uint16_t = true;
            }
        }
        _this.nodeText = node.flags & ts.NodeFlags.Synthesized ? "(synthesized node)" : node.getText();
        return _this;
        var _a;
    }
    CArithmeticExpression = __decorate([
        template_1.CodeTemplate("\n{#if operator}\n    {left} {operator} {right}\n{#elseif computeOperation && isCompoundAssignment}\n    {left} = js_var_compute({left}, {computeOperation}, {right})\n{#elseif computeOperation}\n    js_var_compute({left}, {computeOperation}, {right})\n{#else}\n    /* unsupported arithmetic expression {nodeText} */\n{/if}")
    ], CArithmeticExpression);
    return CArithmeticExpression;
}(template_1.CTemplateBase));
var CRelationalExpression = /** @class */ (function (_super) {
    __extends(CRelationalExpression, _super);
    function CRelationalExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.operator = null;
        _this.universalCondition = null;
        _this.stringCondition = null;
        var leftType = scope.root.typeHelper.getCType(node.left);
        var rightType = scope.root.typeHelper.getCType(node.right);
        if (leftType === ctypes_1.UniversalVarType || rightType === ctypes_1.UniversalVarType) {
            switch (node.operatorToken.kind) {
                case ts.SyntaxKind.LessThanToken:
                    _this.left = new typeconvert_1.CAsUniversalVar(scope, node.left);
                    _this.right = new typeconvert_1.CAsUniversalVar(scope, node.right);
                    _this.universalCondition = "> 0";
                    break;
                case ts.SyntaxKind.LessThanEqualsToken:
                    // notice operands are swapped
                    _this.left = new typeconvert_1.CAsUniversalVar(scope, node.right);
                    _this.right = new typeconvert_1.CAsUniversalVar(scope, node.left);
                    _this.universalCondition = "< 0";
                    break;
                case ts.SyntaxKind.GreaterThanToken:
                    // notice operands are swapped
                    _this.left = new typeconvert_1.CAsUniversalVar(scope, node.right);
                    _this.right = new typeconvert_1.CAsUniversalVar(scope, node.left);
                    _this.universalCondition = "> 0";
                    break;
                case ts.SyntaxKind.GreaterThanEqualsToken:
                    _this.left = new typeconvert_1.CAsUniversalVar(scope, node.left);
                    _this.right = new typeconvert_1.CAsUniversalVar(scope, node.right);
                    _this.universalCondition = "< 0";
                    break;
            }
            scope.root.headerFlags.js_var_lessthan = true;
        }
        else if (leftType === ctypes_1.StringVarType && rightType === ctypes_1.StringVarType) {
            _this.stringCondition = node.operatorToken.getText() + " 0";
            _this.left = template_1.CodeTemplateFactory.createForNode(scope, node.left);
            _this.right = template_1.CodeTemplateFactory.createForNode(scope, node.right);
            scope.root.headerFlags.strings = true;
        }
        else {
            _this.operator = node.operatorToken.getText();
            _this.left = new typeconvert_1.CAsNumber(scope, node.left);
            _this.right = new typeconvert_1.CAsNumber(scope, node.right);
        }
        _this.nodeText = node.flags & ts.NodeFlags.Synthesized ? "(synthesized node)" : node.getText();
        return _this;
    }
    CRelationalExpression = __decorate([
        template_1.CodeTemplate("\n{#if operator}\n    {left} {operator} {right}\n{#elseif stringCondition}\n    strcmp({left}, {right}) {stringCondition}\n{#elseif universalCondition}\n    js_var_lessthan({left}, {right}) {universalCondition}\n{#else}\n    /* unsupported relational expression {nodeText} */\n{/if}")
    ], CRelationalExpression);
    return CRelationalExpression;
}(template_1.CTemplateBase));
var CEqualityExpression = /** @class */ (function (_super) {
    __extends(CEqualityExpression, _super);
    function CEqualityExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.expression = null;
        _this.operator = null;
        _this.stringCondition = null;
        _this.strNumCondition = null;
        _this.universalCondition = null;
        _this.strict = null;
        var leftType = scope.root.typeHelper.getCType(node.left);
        var rightType = scope.root.typeHelper.getCType(node.right);
        var notEquals = node.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsEqualsToken || node.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsToken;
        _this.strict = node.operatorToken.kind === ts.SyntaxKind.ExclamationEqualsEqualsToken || node.operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken ? "TRUE" : "FALSE";
        _this.left = template_1.CodeTemplateFactory.createForNode(scope, node.left);
        _this.right = template_1.CodeTemplateFactory.createForNode(scope, node.right);
        if ((leftType == ctypes_1.NumberVarType || leftType == ctypes_1.BooleanVarType) && (rightType == ctypes_1.NumberVarType || rightType == ctypes_1.BooleanVarType)) {
            _this.operator = notEquals ? "!=" : "==";
        }
        else if (leftType == ctypes_1.StringVarType && rightType == ctypes_1.StringVarType) {
            _this.stringCondition = notEquals ? "!= 0" : "== 0";
            scope.root.headerFlags.strings = true;
        }
        else if (leftType == ctypes_1.NumberVarType && rightType == ctypes_1.StringVarType
            || leftType == ctypes_1.StringVarType && rightType == ctypes_1.NumberVarType) {
            _this.strNumCondition = notEquals ? "!= 0" : "== 0";
            scope.root.headerFlags.str_int16_t_cmp = true;
            // str_int16_t_cmp expects certain order of arguments (string, number)
            if (leftType == ctypes_1.NumberVarType) {
                var tmp = _this.left;
                _this.left = _this.right;
                _this.right = tmp;
            }
        }
        else if (leftType == ctypes_1.UniversalVarType || rightType == ctypes_1.UniversalVarType) {
            _this.universalCondition = notEquals ? "== FALSE" : "== TRUE";
            _this.left = new typeconvert_1.CAsUniversalVar(scope, _this.left, leftType);
            _this.right = new typeconvert_1.CAsUniversalVar(scope, _this.right, rightType);
            scope.root.headerFlags.js_var_eq = true;
        }
        else if (leftType instanceof ctypes_1.StructType || leftType instanceof ctypes_1.ArrayType || leftType instanceof ctypes_1.DictType
            || rightType instanceof ctypes_1.StructType || rightType instanceof ctypes_1.ArrayType || rightType instanceof ctypes_1.DictType) {
            if (leftType != rightType) {
                _this.expression = notEquals ? "TRUE" : "FALSE";
                scope.root.headerFlags.bool = true;
            }
            else
                _this.operator = notEquals ? "!=" : "==";
        }
        _this.nodeText = node.flags & ts.NodeFlags.Synthesized ? "(synthesized node)" : node.getText();
        return _this;
    }
    CEqualityExpression = __decorate([
        template_1.CodeTemplate("\n{#if expression}\n    {expression}\n{#elseif operator}\n    {left} {operator} {right}\n{#elseif stringCondition}\n    strcmp({left}, {right}) {stringCondition}\n{#elseif strNumCondition}\n    str_int16_t_cmp({left}, {right}) {strNumCondition}\n{#elseif universalCondition}\n    js_var_eq({left}, {right}, {strict}) {universalCondition}\n{#else}\n    /* unsupported equality expression {nodeText} */\n{/if}")
    ], CEqualityExpression);
    return CEqualityExpression;
}(template_1.CTemplateBase));
var CPlusExpression = /** @class */ (function (_super) {
    __extends(CPlusExpression, _super);
    function CPlusExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.addNumbers = false;
        _this.isUniversalVar = false;
        _this.replacedWithVar = false;
        _this.replacementVarName = null;
        _this.gcVarName = null;
        var leftType = scope.root.typeHelper.getCType(node.left);
        _this.left = template_1.CodeTemplateFactory.createForNode(scope, node.left);
        var rightType = scope.root.typeHelper.getCType(node.right);
        _this.right = template_1.CodeTemplateFactory.createForNode(scope, node.right);
        if (leftType == ctypes_1.RegexVarType) {
            leftType = ctypes_1.StringVarType;
            _this.left = new regexfunc_1.CRegexAsString(_this.left);
        }
        if (rightType == ctypes_1.RegexVarType) {
            rightType = ctypes_1.StringVarType;
            _this.right = new regexfunc_1.CRegexAsString(_this.right);
        }
        if ((leftType === ctypes_1.NumberVarType || leftType === ctypes_1.BooleanVarType) && (rightType === ctypes_1.NumberVarType || rightType === ctypes_1.BooleanVarType)) {
            _this.addNumbers = true;
        }
        else if (leftType === ctypes_1.UniversalVarType || rightType === ctypes_1.UniversalVarType) {
            _this.isUniversalVar = true;
            _this.left = new typeconvert_1.CAsUniversalVar(scope, _this.left, leftType);
            _this.right = new typeconvert_1.CAsUniversalVar(scope, _this.right, rightType);
            scope.root.headerFlags.js_var_plus = true;
        }
        else {
            var tempVarName = scope.root.memoryManager.getReservedTemporaryVarName(node);
            scope.func.variables.push(new variable_1.CVariable(scope, tempVarName, "char *", { initializer: "NULL" }));
            _this.gcVarName = scope.root.memoryManager.getGCVariableForNode(node);
            _this.replacedWithVar = true;
            _this.replacementVarName = tempVarName;
            _this.strlen_left = new typeconvert_1.CAsString_Length(scope, node.left, _this.left, leftType);
            _this.strlen_right = new typeconvert_1.CAsString_Length(scope, node.right, _this.right, rightType);
            _this.strcat_left = new typeconvert_1.CAsString_Concat(scope, node.left, tempVarName, _this.left, leftType);
            _this.strcat_right = new typeconvert_1.CAsString_Concat(scope, node.right, tempVarName, _this.right, rightType);
            scope.root.headerFlags.strings = true;
            scope.root.headerFlags.malloc = true;
            scope.root.headerFlags.str_int16_t_cat = true;
            if (_this.gcVarName) {
                scope.root.headerFlags.gc_iterator = true;
                scope.root.headerFlags.array = true;
            }
        }
        return _this;
    }
    CPlusExpression = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {#if replacedWithVar}\n        {replacementVarName} = malloc({strlen_left} + {strlen_right} + 1);\n        assert({replacementVarName} != NULL);\n        {replacementVarName}[0] = '\\0';\n        {strcat_left}\n        {strcat_right}\n    {/if}\n    {#if replacedWithVar && gcVarName}\n        ARRAY_PUSH({gcVarName}, {replacementVarName});\n    {/if}\n\n{/statements}\n{#if addNumbers}\n    {left} + {right}\n{#elseif replacedWithVar}\n    {replacementVarName}\n{#elseif isUniversalVar}\n    js_var_plus({left}, {right})\n{/if}")
    ], CPlusExpression);
    return CPlusExpression;
}(template_1.CTemplateBase));
var CInExpression = /** @class */ (function (_super) {
    __extends(CInExpression, _super);
    function CInExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.isArray = false;
        _this.isStruct = false;
        _this.isDict = false;
        _this.isUniversalVar = false;
        _this.result = null;
        _this.tmpVarName = null;
        var type = scope.root.typeHelper.getCType(node.right);
        _this.obj = template_1.CodeTemplateFactory.createForNode(scope, node.right);
        if (type instanceof ctypes_1.ArrayType) {
            _this.isArray = true;
            _this.arraySize = new elementaccess_1.CArraySize(scope, _this.obj, type);
            _this.key = new typeconvert_1.CAsNumber(scope, node.left);
            var keyType = scope.root.typeHelper.getCType(node.left);
            if (utils_1.toNumberCanBeNaN(keyType)) {
                _this.tmpVarName = scope.root.symbolsHelper.addTemp(node, "tmp_key");
                scope.variables.push(new variable_1.CVariable(scope, _this.tmpVarName, ctypes_1.UniversalVarType));
            }
        }
        else {
            _this.key = new typeconvert_1.CAsString(scope, node.left);
        }
        if (type instanceof ctypes_1.StructType) {
            _this.isStruct = true;
            var propTypes = Object.keys(type.properties);
            if (propTypes.length == 0) {
                _this.result = "FALSE";
                scope.root.headerFlags.bool = true;
            }
            else {
                var initializer = "{ " + propTypes.sort().map(function (p) { return '"' + p + '"'; }).join(", ") + " }";
                _this.propertiesVarName = type.structName + "_props";
                _this.propertiesCount = propTypes.length + "";
                if (!scope.root.variables.some(function (v) { return v.name === _this.propertiesVarName; }))
                    scope.root.variables.push(new variable_1.CVariable(scope, _this.propertiesVarName, "const char *{var}[" + _this.propertiesCount + "]", { initializer: initializer }));
                scope.root.headerFlags.dict_find_pos = true;
            }
        }
        _this.isDict = type instanceof ctypes_1.DictType;
        _this.isUniversalVar = type === ctypes_1.UniversalVarType;
        if (ts.isStringLiteral(node.left)) {
            var ident_1 = ts.createIdentifier(node.left.text);
            var propAccess_1 = ts.createPropertyAccess(node.right, ident_1);
            var standardCall = ts.createCall(propAccess_1, [], []);
            ident_1.parent = propAccess_1;
            ident_1.getText = function () { return ident_1.text; };
            propAccess_1.parent = standardCall;
            propAccess_1.getText = function () { return "(" + node.right.getText() + ")." + ident_1.text; };
            standardCall.parent = node.parent;
            standardCall.getText = function () { return propAccess_1.getText() + "()"; };
            if (standard_1.StandardCallHelper.isStandardCall(scope.root.typeHelper, standardCall))
                _this.result = "TRUE";
        }
        if (_this.isArray && ts.isStringLiteral(node.left) && node.left.text === "length")
            _this.result = "TRUE";
        _this.nodeText = node.getText();
        return _this;
    }
    CInExpression = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {#if tmpVarName}\n        {tmpVarName} = {key};\n    {/if}\n{/statements}\n{#if result}\n    {result}\n{#elseif isArray && tmpVarName}\n    ({tmpVarName}.type != JS_VAR_NAN && {tmpVarName}.number >= 0 && {tmpVarName}.number < {arraySize})\n{#elseif isArray && !tmpVarName}\n    ({key} >= 0 && {key} < {arraySize})\n{#elseif isStruct}\n    dict_find_pos({propertiesVarName}, {propertiesCount}, {key}) > -1\n{#elseif isDict}\n    dict_find_pos({obj}->index->data, {obj}->index->size, {key}) > -1\n{#elseif isUniversalVar}\n    js_var_get({obj}, {key}).type != JS_VAR_UNDEFINED\n{#else}\n    /* unsupported 'in' expression {nodeText} */\n{/if}")
    ], CInExpression);
    return CInExpression;
}(template_1.CTemplateBase));
var CUnaryExpression = /** @class */ (function (_super) {
    __extends(CUnaryExpression, _super);
    function CUnaryExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.before = "";
        _this.after = "";
        _this.argumentExpr = null;
        _this.incrementBy = "";
        _this.isCompound = false;
        _this.isPostfix = ts.isPostfixUnaryExpression(node);
        var isTopExpressionOfStatement = ts.isExpressionStatement(node.parent);
        var type = scope.root.typeHelper.getCType(node.operand);
        if (node.operator === ts.SyntaxKind.PlusToken)
            _this.operand = new typeconvert_1.CAsNumber(scope, node.operand);
        else if (node.operator === ts.SyntaxKind.MinusToken) {
            _this.before = "-";
            _this.operand = new typeconvert_1.CAsNumber(scope, node.operand);
            if (utils_1.toNumberCanBeNaN(type)) {
                _this.before = "js_var_compute(js_var_from_int16_t(0), JS_VAR_MINUS, ";
                _this.after = ")";
                scope.root.headerFlags.js_var_compute = true;
                scope.root.headerFlags.js_var_from_int16_t = true;
            }
        }
        else if (node.operator === ts.SyntaxKind.TildeToken) {
            _this.before = "~";
            _this.operand = new typeconvert_1.CAsNumber(scope, node.operand);
            if (utils_1.toNumberCanBeNaN(type))
                _this.after = ".number";
        }
        else if (node.operator === ts.SyntaxKind.ExclamationToken) {
            _this.before = "!";
            _this.operand = new CCondition(scope, node.operand);
        }
        else if (node.operator === ts.SyntaxKind.PlusPlusToken || node.operator === ts.SyntaxKind.MinusMinusToken) {
            var plus_1 = node.operator === ts.SyntaxKind.PlusPlusToken;
            var accessObj = null, isDict = false;
            if ((ts.isPropertyAccessExpression(node.operand) || ts.isElementAccessExpression(node.operand))) {
                _this.argumentExpr = template_1.CodeTemplateFactory.createForNode(scope, ts.isPropertyAccessExpression(node.operand) ? node.operand.name : node.operand.argumentExpression);
                accessObj = node.operand.expression;
                isDict = scope.root.typeHelper.getCType(accessObj) instanceof ctypes_1.DictType;
            }
            if (_this.isPostfix) {
                if (!isDict && (type === ctypes_1.NumberVarType || type === ctypes_1.BooleanVarType)) {
                    _this.operand = template_1.CodeTemplateFactory.createForNode(scope, node.operand);
                    _this.after = plus_1 ? "++" : "--";
                }
                else if (isDict) {
                    _this.operand = template_1.CodeTemplateFactory.createForNode(scope, accessObj);
                    _this.incrementBy = plus_1 ? "1" : "-1";
                    scope.root.headerFlags.js_var_dict_inc = true;
                }
                else if (type === ctypes_1.UniversalVarType) {
                    _this.before = "js_var_inc(&";
                    _this.operand = template_1.CodeTemplateFactory.createForNode(scope, node.operand);
                    _this.after = ", " + (plus_1 ? "1" : "-1") + ")";
                    scope.root.headerFlags.js_var_inc = true;
                }
                else {
                    _this.operand = "/* expression is not yet supported " + node.getText() + " */";
                }
            }
            else {
                if (!isDict && (type === ctypes_1.NumberVarType || type === ctypes_1.BooleanVarType)) {
                    _this.operand = template_1.CodeTemplateFactory.createForNode(scope, node.operand);
                    _this.before = plus_1 ? "++" : "--";
                }
                else if (!isDict && !utils_1.toNumberCanBeNaN(type)) {
                    _this.isCompound = true;
                    _this.operand = new typeconvert_1.CAsNumber(scope, node.operand);
                    _this.after = plus_1 ? " + 1" : " - 1";
                }
                else if (isTopExpressionOfStatement) {
                    var applyOperation = plus_1 ? ts.createAdd : ts.createSubtract;
                    var binExpr = applyOperation(node.operand, ts.createNumericLiteral("1"));
                    binExpr.parent = node;
                    binExpr.getText = function () { return node.operand.getText() + (plus_1 ? "+" : "-") + "1"; };
                    binExpr.operatorToken.getText = function () { return plus_1 ? "+" : "-"; };
                    binExpr.right.getText = function () { return "1"; };
                    scope.root.typeHelper.registerSyntheticNode(binExpr, ctypes_1.UniversalVarType);
                    _this.operand = assignment_1.AssignmentHelper.create(scope, node.operand, binExpr);
                }
                else if (!isDict && plus_1) {
                    _this.isCompound = true;
                    _this.before = "js_var_plus(js_var_to_number(";
                    _this.operand = template_1.CodeTemplateFactory.createForNode(scope, node.operand);
                    _this.after = "), js_var_from_int16_t(1))";
                    scope.root.headerFlags.js_var_plus = true;
                    scope.root.headerFlags.js_var_from_int16_t = true;
                }
                else if (!isDict && !plus_1) {
                    _this.isCompound = true;
                    _this.before = "js_var_compute(js_var_to_number(";
                    _this.operand = template_1.CodeTemplateFactory.createForNode(scope, node.operand);
                    _this.after = "), JS_VAR_MINUS, js_var_from_int16_t(1))";
                    scope.root.headerFlags.js_var_compute = true;
                    scope.root.headerFlags.js_var_from_int16_t = true;
                }
                else {
                    _this.operand = template_1.CodeTemplateFactory.createForNode(scope, accessObj);
                    _this.incrementBy = plus_1 ? "1" : "-1";
                    scope.root.headerFlags.js_var_dict_inc = true;
                }
            }
        }
        else {
            _this.operand = "/* not supported unary expression " + node.getText() + " */";
        }
        return _this;
    }
    CUnaryExpression = __decorate([
        template_1.CodeTemplate("\n{#if isCompound}\n    ({operand} = {before}{operand}{after})\n{#elseif incrementBy && isPostfix}\n    js_var_dict_inc({operand}, {argumentExpr}, {incrementBy}, TRUE)\n{#elseif incrementBy}\n    js_var_dict_inc({operand}, {argumentExpr}, {incrementBy}, FALSE)\n{#else}\n    {before}{operand}{after}\n{/if}", [ts.SyntaxKind.PrefixUnaryExpression, ts.SyntaxKind.PostfixUnaryExpression])
    ], CUnaryExpression);
    return CUnaryExpression;
}(template_1.CTemplateBase));
var CTernaryExpression = /** @class */ (function (_super) {
    __extends(CTernaryExpression, _super);
    function CTernaryExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.condition = template_1.CodeTemplateFactory.createForNode(scope, node.condition);
        _this.whenTrue = template_1.CodeTemplateFactory.createForNode(scope, node.whenTrue);
        _this.whenFalse = template_1.CodeTemplateFactory.createForNode(scope, node.whenFalse);
        return _this;
    }
    CTernaryExpression = __decorate([
        template_1.CodeTemplate("{condition} ? {whenTrue} : {whenFalse}", ts.SyntaxKind.ConditionalExpression)
    ], CTernaryExpression);
    return CTernaryExpression;
}(template_1.CTemplateBase));
var CGroupingExpression = /** @class */ (function (_super) {
    __extends(CGroupingExpression, _super);
    function CGroupingExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.expression = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
        return _this;
    }
    CGroupingExpression = __decorate([
        template_1.CodeTemplate("({expression})", ts.SyntaxKind.ParenthesizedExpression)
    ], CGroupingExpression);
    return CGroupingExpression;
}(template_1.CTemplateBase));
var CTypeOf = /** @class */ (function (_super) {
    __extends(CTypeOf, _super);
    function CTypeOf(scope, node) {
        var _this = _super.call(this) || this;
        var type = scope.root.typeHelper.getCType(node.expression);
        _this.isUniversalVar = type === ctypes_1.UniversalVarType;
        _this.isString = type === ctypes_1.StringVarType;
        _this.isNumber = type === ctypes_1.NumberVarType;
        _this.isBoolean = type === ctypes_1.BooleanVarType;
        _this.expression = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
        if (type == ctypes_1.UniversalVarType) {
            scope.root.headerFlags.js_var = true;
            scope.root.headerFlags.js_var_typeof = true;
        }
        return _this;
    }
    CTypeOf = __decorate([
        template_1.CodeTemplate("\n{#if isUniversalVar}\n    js_var_typeof({expression})\n{#elseif isString}\n    \"string\"\n{#elseif isNumber}\n    \"number\"\n{#elseif isBoolean}\n    \"number\"\n{#else}\n    \"object\"\n{/if}", ts.SyntaxKind.TypeOfExpression)
    ], CTypeOf);
    return CTypeOf;
}(template_1.CTemplateBase));
var CVoid = /** @class */ (function (_super) {
    __extends(CVoid, _super);
    function CVoid(scope, node) {
        var _this = _super.call(this) || this;
        _this.expression = template_1.CodeTemplateFactory.createForNode(scope, node.expression);
        scope.root.headerFlags.js_var = true;
        scope.root.headerFlags.js_var_to_undefined = true;
        return _this;
    }
    CVoid = __decorate([
        template_1.CodeTemplate("js_var_to_undefined({expression})", ts.SyntaxKind.VoidExpression)
    ], CVoid);
    return CVoid;
}(template_1.CTemplateBase));
var CDelete = /** @class */ (function (_super) {
    __extends(CDelete, _super);
    function CDelete(scope, node) {
        var _this = _super.call(this) || this;
        _this.topExpressionOfStatement = node.parent.kind == ts.SyntaxKind.ExpressionStatement;
        _this.dict = (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))
            && template_1.CodeTemplateFactory.createForNode(scope, node.expression.expression);
        if (ts.isElementAccessExpression(node.expression))
            _this.argExpression = ts.isNumericLiteral(node.expression.argumentExpression)
                ? '"' + node.expression.argumentExpression.text + '"'
                : template_1.CodeTemplateFactory.createForNode(scope, node.expression.argumentExpression);
        else if (ts.isPropertyAccessExpression(node.expression))
            _this.argExpression = new literals_1.CString(scope, node.expression.name.text);
        _this.tempVarName = scope.root.symbolsHelper.addTemp(node, "tmp_dict_pos");
        scope.variables.push(new variable_1.CVariable(scope, _this.tempVarName, ctypes_1.NumberVarType));
        scope.root.headerFlags.bool = true;
        scope.root.headerFlags.array_remove = true;
        return _this;
    }
    CDelete = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {tempVarName} = dict_find_pos({dict}->index->data, {dict}->index->size, {argExpression});\n    if ({tempVarName} >= 0)\n    {\n        ARRAY_REMOVE({dict}->index, {tempVarName}, 1);\n        ARRAY_REMOVE({dict}->values, {tempVarName}, 1);\n    }\n{/statements}\n{#if !topExpressionOfStatement}\n    TRUE\n{/if}", ts.SyntaxKind.DeleteExpression)
    ], CDelete);
    return CDelete;
}(template_1.CTemplateBase));
//# sourceMappingURL=expressions.js.map