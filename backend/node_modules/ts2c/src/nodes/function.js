"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var template_1 = require("../template");
var variable_1 = require("./variable");
var ctypes_1 = require("../types/ctypes");
var standard_1 = require("../standard");
var utils_1 = require("../types/utils");
var CFunctionPrototype = /** @class */ (function (_super) {
    __extends(CFunctionPrototype, _super);
    function CFunctionPrototype(scope, node) {
        var _this = _super.call(this) || this;
        _this.parameters = [];
        var funcType = scope.root.typeHelper.getCType(node);
        _this.returnType = scope.root.typeHelper.getTypeString(funcType.returnType);
        _this.name = node.name.getText();
        _this.parameters = node.parameters.map(function (p, i) { return new variable_1.CVariable(scope, p.name.getText(), funcType.parameterTypes[i], { removeStorageSpecifier: true }); });
        if (funcType.instanceType)
            _this.parameters.unshift(new variable_1.CVariable(scope, "this", funcType.instanceType, { removeStorageSpecifier: true }));
        for (var _i = 0, _a = funcType.closureParams; _i < _a.length; _i++) {
            var p = _a[_i];
            _this.parameters.push(new variable_1.CVariable(scope, p.node.text, p.node, { removeStorageSpecifier: true }));
        }
        return _this;
    }
    CFunctionPrototype = __decorate([
        template_1.CodeTemplate("{returnType} {name}({parameters {, }=> {this}});")
    ], CFunctionPrototype);
    return CFunctionPrototype;
}(template_1.CTemplateBase));
exports.CFunctionPrototype = CFunctionPrototype;
var CFunction = /** @class */ (function (_super) {
    __extends(CFunction, _super);
    function CFunction(root, node) {
        var _this = _super.call(this) || this;
        _this.root = root;
        _this.func = _this;
        _this.parameters = [];
        _this.variables = [];
        _this.scopeVarAllocator = null;
        _this.statements = [];
        _this.parent = root;
        _this.name = node.name && node.name.text;
        if (!_this.name) {
            var funcExprName = "func";
            if (utils_1.isEqualsExpression(node.parent) && node.parent.right == node && ts.isIdentifier(node.parent.left))
                funcExprName = node.parent.left.text + "_func";
            if (ts.isVariableDeclaration(node.parent) && node.parent.initializer == node && ts.isIdentifier(node.parent.name))
                funcExprName = node.parent.name.text + "_func";
            if (ts.isPropertyAssignment(node.parent) && ts.isIdentifier(node.parent.name))
                funcExprName = node.parent.name.text + "_func";
            _this.name = root.symbolsHelper.addTemp(utils_1.findParentSourceFile(node), funcExprName);
        }
        var funcType = root.typeHelper.getCType(node);
        _this.funcDecl = new variable_1.CVariable(_this, _this.name, funcType.returnType, { removeStorageSpecifier: true, arraysToPointers: true });
        _this.parameters = node.parameters.map(function (p, i) {
            return new variable_1.CVariable(_this, p.name.text, funcType.parameterTypes[i], { removeStorageSpecifier: true });
        });
        if (funcType.instanceType)
            _this.parameters.unshift(new variable_1.CVariable(_this, "this", funcType.instanceType, { removeStorageSpecifier: true }));
        if (funcType.needsClosureStruct) {
            var closureParamVarName = root.symbolsHelper.getClosureVarName(node);
            _this.parameters.push(new variable_1.CVariable(_this, closureParamVarName, funcType));
        }
        else {
            for (var _i = 0, _a = funcType.closureParams; _i < _a.length; _i++) {
                var p = _a[_i];
                var type = root.typeHelper.getCType(p.node);
                var ptype = p.assigned ? ctypes_1.getTypeText(type) + "*" : type;
                _this.parameters.push(new variable_1.CVariable(_this, p.node.text, ptype, { removeStorageSpecifier: true }));
            }
        }
        if (funcType.scopeType) {
            var scopeVarName = root.symbolsHelper.getScopeVarName(node);
            _this.variables.push(new variable_1.CVariable(_this, scopeVarName, funcType.scopeType));
            _this.scopeVarAllocator = new variable_1.CVariableAllocation(_this, scopeVarName, funcType.scopeType, node);
        }
        _this.gcVarNames = root.memoryManager.getGCVariablesForScope(node);
        var _loop_1 = function (gcVarName) {
            if (root.variables.filter(function (v) { return v.name == gcVarName; }).length)
                return "continue";
            var gcType = "ARRAY(void *)";
            if (gcVarName.indexOf("_arrays") > -1)
                gcType = "ARRAY(ARRAY(void *))";
            if (gcVarName.indexOf("_arrays_c") > -1)
                gcType = "ARRAY(ARRAY(ARRAY(void *)))";
            if (gcVarName.indexOf("_dicts") > -1)
                gcType = "ARRAY(DICT(void *))";
            root.variables.push(new variable_1.CVariable(root, gcVarName, gcType));
        };
        for (var _b = 0, _c = _this.gcVarNames; _b < _c.length; _b++) {
            var gcVarName = _c[_b];
            _loop_1(gcVarName);
        }
        node.body.statements.forEach(function (s) { return _this.statements.push(template_1.CodeTemplateFactory.createForNode(_this, s)); });
        if (node.body.statements.length > 0 && node.body.statements[node.body.statements.length - 1].kind != ts.SyntaxKind.ReturnStatement) {
            _this.destructors = new variable_1.CVariableDestructors(_this, node);
        }
        var nodesInFunction = utils_1.getAllNodesUnder(node);
        var declaredFunctionNames = root.functions.concat(root.functionPrototypes).map(function (f) { return f.name; });
        nodesInFunction.filter(function (n) { return ts.isCallExpression(n) && !standard_1.StandardCallHelper.isStandardCall(root.typeHelper, n); })
            .forEach(function (c) {
            if (ts.isIdentifier(c.expression) && declaredFunctionNames.indexOf(c.expression.text) === -1) {
                var decl = root.typeHelper.getDeclaration(c.expression);
                if (decl && decl !== node && ts.isFunctionDeclaration(decl)) {
                    root.functionPrototypes.push(new CFunctionPrototype(root, decl));
                    declaredFunctionNames.push(decl.name.text);
                }
            }
        });
        return _this;
    }
    CFunction = __decorate([
        template_1.CodeTemplate("\n{funcDecl}({parameters {, }=> {this}})\n{\n    {variables  {    }=> {this};\n}\n    {#if scopeVarAllocator != null}\n        {scopeVarAllocator}\n    {/if}\n    {gcVarNames {    }=> ARRAY_CREATE({this}, 2, 0);\n}\n\n    {statements {    }=> {this}}\n\n    {destructors}\n}")
    ], CFunction);
    return CFunction;
}(template_1.CTemplateBase));
exports.CFunction = CFunction;
var CFunctionExpression = /** @class */ (function (_super) {
    __extends(CFunctionExpression, _super);
    function CFunctionExpression(scope, node) {
        var _this = _super.call(this) || this;
        _this.expression = '';
        _this.isClosureFunc = false;
        var type = scope.root.typeHelper.getCType(node);
        var parentFunc = utils_1.findParentFunction(node.parent);
        if (type instanceof ctypes_1.FuncType && type.needsClosureStruct && parentFunc) {
            var parentFuncType = scope.root.typeHelper.getCType(parentFunc);
            _this.isClosureFunc = true;
            _this.closureVarName = scope.root.memoryManager.getReservedTemporaryVarName(node);
            scope.root.symbolsHelper.ensureClosureStruct(type, parentFuncType, _this.closureVarName);
            if (!scope.root.memoryManager.variableWasReused(node))
                scope.variables.push(new variable_1.CVariable(scope, _this.closureVarName, type));
            _this.allocator = new variable_1.CVariableAllocation(scope, _this.closureVarName, type, node);
            /** since we're anyway passing the whole scope object, probably a good idea to move this fragment into @see CFunction */
            _this.scopeVarName = parentFuncType && scope.root.symbolsHelper.getScopeVarName(node);
            var parentClosureVarName = parentFuncType && parentFuncType.needsClosureStruct && scope.root.symbolsHelper.getClosureVarName(parentFunc);
            var prefix_1 = parentClosureVarName ? parentClosureVarName + "->scope->" : "";
            var closureParamsFromParent = parentFuncType.closureParams.map(function (p) { return ({ key: p.node.text, value: prefix_1 + p.node.text }); });
            var paramsFromParent = type.closureParams.filter(function (p) { return scope.root.typeHelper.getDeclaration(p.node).parent === parentFunc; }).map(function (p) { return ({ key: p.node.text, value: p.node.text }); });
            _this.closureParams = closureParamsFromParent.concat(paramsFromParent);
        }
        var func = new CFunction(scope.root, node);
        scope.root.functions.push(func);
        _this.name = func.name;
        if (ts.isFunctionExpression(node))
            _this.expression = _this.closureVarName || func.name;
        return _this;
    }
    CFunctionExpression = __decorate([
        template_1.CodeTemplate("\n{#statements}\n    {#if isClosureFunc}\n        {closureParams => {scopeVarName}->{key} = {value};\n}\n        {allocator}\n        {closureVarName}->func = {name};\n        {closureVarName}->scope = {scopeVarName};\n    {/if}\n{/statements}\n{expression}", [ts.SyntaxKind.FunctionExpression, ts.SyntaxKind.FunctionDeclaration])
    ], CFunctionExpression);
    return CFunctionExpression;
}(template_1.CTemplateBase));
exports.CFunctionExpression = CFunctionExpression;
//# sourceMappingURL=function.js.map